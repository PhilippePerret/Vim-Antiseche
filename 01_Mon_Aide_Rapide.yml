#
# Utiliser Mon_Aide_Rapide.rb avec CMD+i pour reconstruire la cheat sheet
# Mon_Aide_Rapide.html
#
#
# Marquer une commande avec `:important: true` si elle doit être mise en
# exergue.
#
---
# ---------------------------------------------------------------------
#
#   @@@ VIMINFO
#
# ---------------------------------------------------------------------

  VIMINFO:

    -
      :main_action: Définir
      :action: "les éléments à sauver dans le fichier viminfo"
      :mode: command
      :code: ":set viminfo"
      :c:    ':set vi=<paramètres>'
      :values:
        '<parametres>':
          - "`'<nombre>` : le nombre de fichiers pour lesquels il faut sauver les marques locales. P.e. `:set vi='1000`"
          - '`f1`/`f0` : sauvegarde ou non des marques globales. P.e. `:set vi=f1` (oui)'
          - '`/<nombre>` : nombre de lignes d’historique de recherche (entreprises par `/`). P.e. `:set vi=/100` => 100 lignes de recherche'
          - '`%` : conservation de la liste des buffers. P.e. `:set vi=%`'
          - '`!` : conservation des variables globales. P.e. `:set vi=!`'
      :exemples:
        - "`:set viminfo='1000,f1,:100,/100,%,!` => on conserve les marques locales de 1000 fichiers (`'1000`), qu'on conserve les marques globales (`f1`), qu'on conserve 100 lignes d’history (`:100`) et 100 ligne d'historique de recherche (`/100`), qu'on sauve et restaure la liste des buffers (`%`) et qu'on sauve les variables globales (`!`)."

    -
      :main_action: Forcer l’écriture
      :action:      de viminfo
      :mode: command
      :code: ":wviminfo[!] [path/to/fichier]"
      :note: "Sans précision de fichier, c'est le fichier `~/.viminfo` qui sera utilisé."

    -
      :main_action: "Forcer la lecture"
      :action: "du viminfo"
      :mode: normal
      :code: ":rviminfo[!] [path/to/fichier]"
      :note: "Sans précision de fichier, c'est le fichier `~/.viminfo` qui sera utilisé."

# ---------------------------------------------------------------------
#
#   @@@ AIDE
#
# ---------------------------------------------------------------------

  HELP:

    -
      :main_action: Ouvrir
      :action:      l’aide
      :mode: command
      :code: ':help'
      :c:     ':h'
      :memo: "((h))elp"
      :tags: aide

    -
      :main_action: Tagger
      :action:      un dossier
      :mode: command
      :code: ':! ctags -R .'
      :note:
        - '« tagger un dossier » consiste à repérer toutes les fonctions, les définitions, etc.'
        - 'Il faut se trouver à la racine du dossier voulu (dossier du programme)'
        - 'On peut définir le fichier où seront placées les tags avec l’option `-f <path/to/file>`'
        - 'Ça fonctionne parfaitement en Ruby'
        - 'On peut le faire en dehors de Vim, puisque c’est une ligne de commande : `ctags -R .`'

    -
      :main_action: Se rendre
      :action:      à une tag
      :mode: normal
      :code: CTRL KeyDollar
      :exemples:
        - 'Se placer sur l’utilisation d’une méthode, taper `CTRL KeyDollar` => Vim ouvre le fichier contenant la définition de la méthode et l’affiche.'
      :notes:
        - '« se rendre à une tag » signifie par exemple « se rendre à la définition d’une fonction/méthode »'
        - 'Utiliser `CTRL KeyT` pour revenir à l’endroit précédent'
        - 'Normalement, c’est `CTRL ]`, mais ça ne fonctionne pas sur Mac'
      :tags: tag

    -
      :main_action: Revenir
      :action:      à la position précédente (après avoir cherché une tag)
      :mode: normal
      :code: 'CTRL KeyT'
      :memo: '((T))ag'
      :tags: tag

    -
      :main_action: Passer en revue
      :action:      les tags parcourues (au cours de la session)
      :mode: normal
      :code: CTRL KeyO
      :tags: tag

    -
      :main_action: Obtenir l’aide
      :action:      d’une commande dans un mode particulier
      :mode: normal
      :code: ':help <préfixe mode>_<commande>'
      :c:    ':h <pref>_<commande>'
      :values:
        '<préfixe mode>':
          - '`i` pour mode insertion'
          - '`v` pour mode visual'
          - '`c` pour mode command'
      :exemples:
        - "`:h i_CTRL-H` => conduit à l’aide sur la command `CTRL KeyH` en mode insertion"
      :tags: aide commande

    -
      :main_action: Obtenir l’aide
      :action:      sur une option
      :code: ":help '<option>'"
      :c:    ":h '<option>'"
      :note: "Il faut l'entourer d’apostrophes simple"
      :exemples:
        - "`:help 'nowrap'` => conduit à l’aide à propos de l’option « nowrap »"
      :tags: aide option

    -
      :main_action: Obtenir de l’aide
      :action:      sur le mot sous le curseur
      :mode: normal
      :code: 'MAJ KeyK'
      :memo: "((K))eyword lookup"

    -
      :main_action: Lancer Vim
      :action:      en mode Verbose
      :code: '$> vim -V <nombre>'
      :memo: '((V))erbeux'
      :note: 'Utile pour débugger les scripts Vim.'

    -
      :main_action: Définir
      :action:      la hauteur de la fenêtre d’aide
      :mode: command
      :code: ':set helpheight=<nombre de lignes>'


# ---------------------------------------------------------------------
#
#   @@@ PREMIÈRES COMMANDES UTILES
#
# ---------------------------------------------------------------------

  PREMIÈRES COMMANDES UTILES:

    -
      :main_action: Activer le mode
      :action:      INSERT en se plaçant au bout de la ligne
      :mode: normal
      :code: MAJ KeyA
      :important: true

    -
      :main_action: Activer le mode
      :action:      INSERT en se plaçant après le caractère courant
      :mode: normal
      :code: KeyA

    -
      :main_action: Activer le mode
      :action:      INSERT avant le caractère courant
      :mode: normal
      :code: KeyI
      :note: La première touche frappée ajoutera un caractère avant le curseur.

    -
      :main_action: Activer le mode
      :action:      VISUAL normal
      :mode: normal
      :code: KeyV
      :note: 'Le mode visual « normal » se distingue du mode par ligne et du mode par block.'

    -
      :main_action: Activer le mode
      :action:      VISUAL ligne
      :mode: normal
      :code: MAJ KeyV
      :note: 'Le mode visual « ligne » permet de sélectionner des lignes entières.'

    -
      :main_action: Activer le mode
      :action:      VISUAL block
      :mode: normal
      :code: CTRL KeyV
      :note: 'Le mode visual « block » permet de sélectionner des blocks de signes, sans tenir compte des lignes, comme si c’était un dessin. Cf. l’exemple.'
      :exemples:
        "`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;C<sel>eci est u</sel>n dessin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;U<sel>une sorte</sel>de dessin&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;P<sel>our pouvo</sel> sélectionner&nbsp;\n&nbsp;T<sel>out en bl</sel>ock.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`"

    -
      :main_action: "Quitter un mode"
      :action: "quelconque, annuler, renoncer"
      :code:
        - ESC
        - CTRL KeyC
      :tags: annuler quitter

    -
      :main_action: Répéter
      :action:  "la dernière action"
      :mode: normal
      :code: ". (MAJ ;)"
      :tags: action

    -
      :main_action: Enregistrer
      :action: "une macro"
      :mode: normal
      :code: "KeyQ<KeyA-KeyZ> <jouer> KeyQ"
      :memo: ((q)) = bout à gauche du clavier
      :tags: macro

    -
      :main_action: Jouer
      :action: "une macro"
      :mode: normal
      :code: "@<a-z>"
      :tags: macro

# ---------------------------------------------------------------------
#
#   @@@ SESSIONS
#
# ---------------------------------------------------------------------

  SESSIONS:

    -
      :main_action: Enregistrer
      :action: la session courante
      :mode: command
      :code: ':mks[ession] <fichier>'
      :memo: '((m))a((k))e ((s))ession'
      :exemples:
        - '`:mksessions session.vim` => enregistre l’état courante dans "session.vim"'


    -
      :main_action: Restaurer
      :action: une session précédente
      :code:
        - '[COMMAND] :so[urce] <fichier session>'
        - '$> vim -c ":source <fichier session>"'
      :exemples:
        - '`:source session.vim` => restaure la session enregistrée dans "session.vim"'
        - '`$> vim -c ":source session.vim"`'

    -
      :main_action: Définir
      :action: ce qui doit être mémorisé dans une session
      :mode: command
      :code: ':set sessionoptions=<element1>,<element2>,<element3>...<elementN>'
      :values:
        '<element>':
          - '`buffers` sauve les buffers'
          - '`globals` sauve les variables globales qui commencent par une majuscule et contiennent au moins une minuscule'
          - '`help` sauve la fenêtre d’aide'
          - '`blank` sauve les fenêtres vides ouvertes'
          - '`options` sauve toutes les options et la carte clavier (keyboard mapping)'
          - '`winpos` sauve les positions de fenêtre (GUI)'
          - '`resize` sauve la taille de l’écran'
          - '`winsize` sauve les tailles des fenêtres si possible'
          - '`slash` sauve les paths escapés (pour utilisation de unix/mac à windaubes)'
          - '`unix` sauve avec des retours chariots unix'


# ---------------------------------------------------------------------
#
#   @@@ MAPPING
#
# ---------------------------------------------------------------------

  MAPPING:

    -
      :main_action: Définition
      :action:      du mapping
      :note: Le mapping est le fait d’associer une touche (ou une combinaison de touches) à une action. C’est une sorte de macro.

    -
      :main_action: Définir
      :action:      une map
      :mode: normal
      :code: ':map <touche> <action>'
      :exemples:
        - '`:map <F1> "ay` => en pressant la touche F1, on copie le texte sélectionner (y) dans le registre "a" (`"a`)'
        - '`:map <F2> "ap` => en pressant la touche F2, on colle le texte du registre "a" au curseur.'
        - '`:map ^A dd` => en pressant CTRL MAJ KeyA, on delete la ligne courante'
        - '`:map ^B ^A` => en pressant CTRL MAJ KeyB, on produit la même action que CTRL MAJ KeyA'

    -
      :main_action: Définir
      :action:      une map pour un mode particulier
      :mode: normal
      :code: ':<lettre mode>map <touche> <action>'
      :exemples:
        - '`:imap CAM Camille` => Taper MAJ KeyC KeyA KeyM produit l’écriture de « Camille ».'
      :note: 'Apparemment, pour que des lettres (par exemple « CAM ») se transforme en autre chose dans le mode [INSERT], il faut vraiment utiliser `imap` (voir l’exemple).'
      :values:
        'lettre mode':
          - '`i` (`im[ap]`) pour le mode [INSERT]'
          - '`c` (`cm[ap]`) pour le mode [COMMAND]'
          - 'Note : `:map!` pour les deux modes [INSERT] et [COMMAND]'
          - '`v` (`vm[ap]`) pour le mode [VISUAL]'
          - '`n` (`nm[ap]`) pour le mode [NORMAL]'
          - '`s` (`sm[ap]`) pour le mode [SELECT]'
          - '`o` (`om[ap]`) pour l’operator pending (mode dans lequel on entre lorsqu’une touche attend une « motion », par exemple « d » pour `delete`)'

    -
      :main_action: Lister
      :action:      toutes les maps
      :mode: normal
      :code: ':map'

    -
      :main_action: Supprimer
      :action:      une map
      :mode: normal
      :code: ':[<mode>]unmap <touche>'

    -
      :main_actin: Supprimer
      :action:     toutes les mappings
      :mode: normal
      :code: ':mapc[lear]'

# ---------------------------------------------------------------------
#
#   @@@ ABRÉVIATION/SNIPPETS
#
# ---------------------------------------------------------------------

  SNIPPETS:

    -
      :main_action: Définir
      :action:      une abbréviation/un snippet
      :code: ':ab[breviate] <snippet> <remplacement>'
      :note: 'Cette abbréviation sera valable pour le mode [INSERT] comme pour le mode [COMMAND]. Utiliser `ia[bbrev]` pour un snippet qui ne fonctionne qu’en mode insertion.'
      :exemples:
        - "`:abbreviate @phil Philippe Perret <philippe.perret@yahoo.fr>` => en tapant `@phil`, on insert le texte 'Philippe Perret etc.'"
        - "`:ab multiline Une définition<CR>Sur plusieurs<CR>lignes` => à mettre dans un fichier à charger ou `.vimrc`."
      :tags: snippet

    -
      :main_action: Définir
      :action:      une abbréviation pour le mode INSERT seulement
      :code: ":ia[bbrev] <snippet> <remplacement>\n[dans fichier config] iabbrev <snippet> <remplacement>"
      :exemples:
        - '`:iabbrev C Camille`'
        - '`:ia J Joaquim`'
      :note: 'On peut utiliser `CTRL KeyDollar` ou `SPACE` pour l’étendre dans mode [INSERT].'
      :tags: snippet

    -
      :main_action: Définir
      :action:      une abbréviation pour le mode COMMAND seulement
      :code: ':ca[bbreviate] <snippet> <remplacement>'
      :exemples:
        - '`:cabbreviate l list`'
        - '`:ca J Joaquim`'
      :tags: snippet

    -
      :main_action: Expendre
      :action:      une abbréviation en mode INSERT
      :mode: insert
      :code:
        - '<snippet>CTRL KeyDollar'
        - '<snippet> SPACE'
      :tags: snippet

    -
      :main_action: Supprimer
      :action:      une abbréviation précédemment définie
      :code: ':una[bbreviate] <snippet>'
      :tags: snippet

    -
      :main_action: Supprimer
      :action:      une abbréviation du mode INSERT
      :code: ':iuna[bbreviate] <snippet>'
      :tags: snippet

    -
      :main_action: Supprimer
      :action:      une abbréviation du mode COMMAND
      :code: ':cuna[bbreviate] <snippet>'
      :tags: snippet

    -
      :main_action: Supprimer
      :action:      toutes les abbréviations
      :mode: normal
      :code: ':abc[lear]'
      :tags: snippet

    -
      :main_action: Supprimer
      :action:      toutes les abbréviations du mode INSERT
      :mode: normal
      :code: ':iabc[lear]'
      :tags: snippet

    -
      :main_action: Supprimer
      :action:      toutes les abbréviations du mode COMMAND
      :mode: normal
      :code: ':cabc[lear]'
      :tags: snippet

    -
      :main_action: Afficher
      :action:      toutes les abbréviations
      :code: ":ab[breviate]"
      :tags: snippet

    -
      :main_action: Enregistrer
      :action:      les abbréviations (et mapping et set) dans un fichier
      :code: ":mkvimrc <path/to/fichier>"
      :memo: "((m))a((k))e ((vimrc))"
      :tags: snippet

    -
      :main_action: Recharger
      :action: "les abbréviations (+ map et set) depuis un fichier (créé avec `mkvimrc`)"
      :code: ":so[urce] <path/to/fichier>"

# ---------------------------------------------------------------------
#
#   @@@ FENETRES
#
# ---------------------------------------------------------------------

  FENÊTRES & LAYOUT:

    -
      :main_action: Ouvrir
      :action: "plusieurs fichiers dans des layouts"
      :code: "$> vim -o file1 path/file2 file3"
      :exemples:
        - "Indiquer un nombre pour limiter le nombre de layouts : `vim -o3`"

    -
      :main_action: Ouvrir
      :action:      la fenêtre alternative
      :mode: normal
      :code: 'CTRL KeyW ^'

    -
      :main_action: Ouvrir
      :action:      dans la fenêtre de prévisualisation
      :mode: normal
      :code: ':pt[ag] <fonction>'
      :note: 'Ouvre la définition de la `<fonction>` dans la fenêtre de prévisualisation.'
      :tags: preview

    -
      :main_action: Fermer
      :action:      la fenêtre de prévisualisation
      :mode: normal
      :code:
        - ':pc[lose]'
        - 'CTRL KeyW CTRL KeyZ'
        - 'CTRL KeyW KeyZ'
      :memo: '((p))review close'
      :tags: preview

    -
      :main_action: Définir
      :action:      la hauteur de la fenêtre de prévisualisation
      :mode: normal
      :code: ':set previewheight=<nombre de lignes>'

    -
      :main_action: Split
      :action:      "(signature générale)"
      :mode: normal
      :code: ":<count> +<commande> sp[lit] <path/to/file>"
      :tags: split

    -
      :main_action: Spliter
      :action:      la fenêtre active
      :code:
        - ':sp[it]'
        - CTRL KeyW KeyN
      :memo: ((sp))iter
      :tags: split fenêtre

    -
      :main_action: Spliter
      :action:      la fenêtre en créant un nouveau fichier dans le nouveau layout
      :mode: normal
      :code: ':new'
      :tags: split fichier

    -
      :main_action: Spliter
      :action:      verticalement la fenêtre active
      :code:
        - ':vs'
        - ':vsp'
        - ':vsplit'
      :memo: ((v))ertical ((sp))lit
      :tags: split fenêtre

    -
      :main_action: Spliter
      :action:      en définissant la taille (lignes) du nouveau layout
      :code: "<nombre ligne>sp"
      :tags: layout ligne

    -
      :main_action: Spliter
      :action:      verticalement en définissant la taille (colonne) du nouveau layout
      :code: "<nombre colonnes>vsp"
      :tags: layout ligne

    -
      :main_action: Faire défiler
      :action:      deux fenêtres en même temps
      :mode: command
      :code: ':set scrollbind'
      :note: 'La procédure exacte est la suivante : il faut ouvrir deux fichiers en splitant verticalement la fenêtre (`:vert split`) puis taper `:set scrollbind` pour chacune des layouts.'

    -
      :main_action: Redimensionner
      :action: "précisément le layout courant"
      :mode: normal
      :code: ":resize [+|-]<nombre>"
      :exemples:
        - "`:resize 10` => mets le layout à 10 lignes"
        - "`:resize +10` => augmente le layout de 10 lignes"
        - "`:resize -10` => diminue le layout de 10 lignes"
      :tags: layout size

    -
      :main_action: Redimensionner
      :action: "verticalement précisément le layout courant"
      :mode: normal
      :code: ":vert :resize [+|-]<nombre>"
      :exemples:
        - "`:vert :resize 100` => mets le layout à 100 colonnes"
        - "`:vert :resize +100` => augmente le layout de 100 colonnes"
        - "`:vert :resize -100` => diminer le layout de 100 colonnes"

    -
      :main_action: Redimensionner
      :action: "le layout en l'aggrandissant"
      :mode: normal
      :code: "CTRL KeyW, [x] MAJ +"
      :tags: layout size

    -
      :main_action: Redimensionner
      :action: "en maximisant le layout courant"
      :mode: normal
      :code:
        - 'CTRL KeyW _ (MAJ -)'
        - ':resize (sans arg)'
      :tags: layout size

    -
      :main_action: Redimensionner
      :action: "le layout en le diminuant"
      :mode: normal
      :code: "CTRL KeyW, [x] -"
      :tags: layout size

    -
      :main_action: Redimensionner
      :action: "tous les layouts à la même taille"
      :mode: normal
      :code: "CTRL KeyW ="
      :tags: layout size

    -
      :main_action: Activer
      :action: "un layout à l'autre"
      :code: CTRL KeyWKeyW
      :memo: CTRL ((w))indow (fenêtre)
      :tags: layout

    -
      :main_action: Activer
      :action: "le layout en dessous"
      :code: "CTRL KeyWKeyJ"
      :memo: "KeyJ comme pour descendre dans Vim"

    -
      :main_action: Activer
      :action: "le layout à droite"
      :code: "CTRL KeyWKeyL"
      :memo: "KeyL comme pour aller à droite dans Vim"

    -
      :main_action: Activer
      :action: "le layout au-dessus"
      :code: "CTRL KeyWKeyK"
      :memo: "KeyK comme pour monter dans Vim"

    -
      :main_action: Activer
      :action: "le layout à gauche"
      :code: "CTRL KeyWKeyH"
      :memo: "KeyH comme pour aller à gauche dans Vim"

    -
      :main_action: Fermer
      :action: "la fenêtre courante"
      :mode: normal
      :code:
        - 'CTRL KeyWKeyQ'
        - 'MAJ KeyZKeyZ'
      :memo: "((w))indow, ((q))uit"
      :tags: fenêtre

    -
      :main_action: Fermer
      :action: toutes les fenêtres sauf la fenêtre courante
      :mode: normal
      :code: CTRL KeyW KeyO

    -
      :main_action: Maximiser
      :action: ", ne garder que la fenêtre courante"
      :code: ":only\nCTRL KeyW MAJ KeyT"
      :memo: "((only)) this window\n((T))all ?"
      :tags: fenêtre

    -
      :main_action: Positionner
      :action: "la ligne courante en haut de l'écran"
      :mode: normal
      :code: "KeyZ ENTER"

    -
      :main_action: Positionner
      :action: "la xième ligne en haut de l'écran"
      :mode: normal
      :code: "[numéro ligne] KeyZ ENTER"

    -
      :main_action: Positionner
      :action: "la ligne courante en bas de l'écran"
      :mode: normal
      :code: "KeyZKeyB"

    -
      :main_action: Positionner
      :action: "la ligne courante au milieu de l'écran"
      :mode: normal
      :code:
        - KeyZKeyZ
        - KeyZ KeyPoint

    -
      :main_action: Exécuter
      :action:      une commande dans toutes les fenêtres ouvertes
      :mode: normal
      :code: ':windo <commande>'
      :exemple:
        - "`:windo :% s/texte/Texte/g` remplace 'texte' par 'Texte' dans toutes les fenêtres ouvertes."

    -
      :main_action: Mémoriser
      :action:      la position des fenêtres et tabs
      :mode: command
      :code: ':mkview <path/to/file.vim>'
      :note: 'ajouter « ! » à la commande pour forcer la réécriture d’un fichier précédent'

    -
      :main_action: Recharger
      :action:      la position des fenêtres et tabs
      :mode: command
      :code: ':source <path/to/file.vim>'
      :note: 'Ce fichier doit avoir été sauvé avec `:mkview`.'

    -
      :main_action: Définir
      :action:      les éléments sauvés par `mkview`
      :code: ':set viewoptions=<L1>,<L2>,...<Lx>'
      :values:
        '<Lx>':
          - '`cursor` sauve la position du curseur'
          - '`folds` sauve l’état courant des foldings'
          - '`options` sauve les options incluant les options locales pour les buffers et fenêtres'

# ---------------------------------------------------------------------
#
#   @@@ TABS
#
# ---------------------------------------------------------------------

  TABS:

    -
      :main_action: Lister
      :action:      toutes les tabs ouvertes
      :mode: command
      :code: ':tabs'

    -
      :main_action: Ouvrir
      :action:      un fichier dans une nouvel tab
      :mode: NORMAL
      :code: ":tabedit path/to/file"

    -
      :main_action: Ouvrir
      :action:      un fichier existant dans une nouvel tab
      :mode: normal
      :code: ":tabfind path/to/file[:<ligne>]"

    -
      :main_action: Ouvrir
      :action:      plusieurs fichiers en même temps dans des tabs
      :code: "$> vim -p file1 path/file2 path/to/file3"
      :exemples:
        - "Ajouter un nombre pour limiter le nombre d'onglets à ouvrir : `vim -p4`"

    -
      :main_action: Fermer
      :action:      la tab courante
      :mode: normal
      :code:
        - MAJ KeyZKeyZ
        - ':close'
        - ':q'

    -
      :main_action: Fermer
      :action:      une tab quelconque
      :mode: normal
      :code: ":tabclose <index tab>"

    -
      :main_action: Fermer
      :action:      toutes les tabs sauf la courante
      :mode: normal
      :code: ":tabo[nly]"
      :memo: "((only)) = seulement"

    -
      :main_action: Activer
      :action:      la tab suivante (première si dernière)
      :mode: normal
      :code: ":tabn[ext]"
      :memo: "((next)) = prochaine"

    -
      :main_action: Activer
      :action:      la tab précédente (dernière si première)
      :mode: normal
      :code:
        - ':tabp[revious]'
        - ':tabN[ext]'
      :memo: "((previous)) = précédente"

    -
      :main_action: Activer
      :action:      la première tab
      :mode: normal
      :code:
        - ':tabfirst'
        - ':tabrewind'
        - ':tabr'

    -
      :main_action: Activer
      :action:      la dernière tab
      :mode: normal
      :code: ":tabl[ast]"

    -
      :main_action: Activer
      :action:      une tab pour son index (1-start)
      :mode: normal
      :code: ":tabn[ext] <index>"

    -
      :main_action: Exécuter une commande
      :action:      dans toutes les tabs ouvertes
      :mode: command
      :code: ':tabdo <commande>'
      :exemples:
        - '`:tabdo :%s/old/new/g` => remplace le texte "old" par "new" dans toutes les tabs.'

    -
      :main_action: Placer
      :action:      une tab après une autre
      :mode: command
      :code: ':tabm[ove]'

    -
      :main_action: Définir
      :action:      quand afficher la ligne d’onglets
      :mode: command
      :code: ':set showtabline=<nombre>'
      :values:
        '<nombre>':
          - '0 : ne jamais afficher'
          - '1 : afficher quand onglets'
          - '2 : toujours afficher'

# ---------------------------------------------------------------------
#
#   @@@ FICHIERS
#
# ---------------------------------------------------------------------

  FICHIERS:

    -
      :main_action: '[Ne plus] Produire'
      :action:      un backup
      :mode: normal
      :code: ":set [no]backup"

    -
      :main_action: Définir
      :action:      une extension propre pour le backup
      :code: ":set backupext=<extension>"
      :exemples:
        - "`:set backuptext=.bak` => le backup de `fichier.txt` sera `fichier.txt.bak`."

    -
      :main_action: Définir
      :action:      le dossier du backup
      :code: ":set backupdir=/path/to/bckup/folder/"
      :note: "Par défaut, c'est le dossier du fichier. Si un dossier est choisi de cette manière, attention aux collisions de noms."

    -
      :main_action: Définir
      :action:      les fichiers à ne pas backuper
      :code: ":set backupskip=..."

    -
      :main_action: Ouvrir
      :action:      le fichier sous le curseur
      :mode: normal
      :code: KeyG KeyF
      :important: true

    -
      :main_action: Ouvrir
      :action:      le fichier en lecture seule (depuis Vim)
      :mode: normal
      :code: ":view path/to/file"

    -
      :main_action: Ouvrir
      :action:      un fichier en lecture seule (depuis Terminal)
      :code:
        - '$> vim -R fichier.ext'
        - '$> view fichier.ext'

    -
      :main_action: Ouvrir
      :action:      un fichier en encryption
      :code: "$> vim -x secret.txt"

    -
      :main_action: Ouvrir un fichier
      :action:      sans swap file
      :code: "$> vim -n secret.txt"
      :note: "Utilisé justement pour les fichier encryptés, afin que les swap-files ne puissent être consultés pendant l'édition du fichier apr un utilisateur qui auraient des superprivilèges."

    -
      :main_action: Ouvrir
      :action:      un fichier quelconque en édition
      :mode: normal
      :code: ":e CTRL KeyD\n=> La liste du dossier courant s'affiche\n<debut>TAB\n=> Le nom se développe."
      :memo: "((e))dit"

    -
      :main_action: Ouvrir
      :action:      un fichier sans enregistrer les changements du fichier précédent
      :mode: normal
      :code: ":e! path/to/file ENTER"
      :memo: "((e))dit ((!)) attention : sans sauver les changements précédents"

    -
      :main_action: Ouvrir
      :action:      un fichier en splitant la fenêtre
      :mode: normal
      :code: ":sp <path/to/file>"
      :memo: "((sp))lit"
      :exemples:
        - "`:sp ~/.vimrc` (ouvre vimrc en splitant la fenêtre)"
      :tags: split

    -
      :main_action: Ouvrir un fichier
      :action:      en se plaçant sur une certaine ligne
      :mode: xterm
      :code: "$> vim +<numéro ligne> <path/to/fichier.ext>"

    -
      :main_action: Ouvrir un fichier
      :action:      en se plaçant sur un mot particulier
      :mode: xterm
      :code: "$> vim +/<search> <path/to/fichier.ext>"

    -
      :main_action: Ouvrir
      :action:      plusieurs fichiers en même temps
      :code: ":next <file1> <file2> etc.\n:args"

    -
      :main_action: Nouveau
      :action:      layout en splitant la fenêtre courante
      :mode: normal
      :code: "CTRL KeyWKeyN"

    -
      :main_action: Enregistrer
      :action:      le fichier courant
      :mode: normal
      :code: ':w[rite]'

    -
      :main_action: Enregistrer
      :action:      tous les fichiers courants (même les buffers cachés)
      :mode: normal
      :code: ":wa[ll]"
      :memo: "((w))rite ((a))ll"

    -
      :main_action: Enregistrer
      :action:      et quitter le fichier courant
      :mode: normal
      :code: :wq
      :memo: "((w))rite ((q))uit"

    -
      :main_action: Enregistrer
      :action:      sous un autre nom
      :mode: normal
      :code: :saveas
      :note: "Toutes les sauvegardes suivantes se feront dans ce fichier, contrairement à `:write` qui n'enregistre que ponctuellement dans un autre fichier."

    -
      :main_action: Enregistrer
      :action:      en forçant un fichier ouvert en lecture seule
      :mode: normal
      :code: ':w[rite]!'

    -
      :main_action: Enregistrer
      :action:      seulement un rang de lignes dans un fichier
      :mode: normal
      :code: ":<de ligne>,<à ligne>KeyW[ <path/to/file.ext]"
      :exemples:
        - "`:20,41 KeyW monfichier.txt` enregistre les lignes 20 à 41 du buffer courant dans le fichier `monfichier.txt`"

    -
      :main_action: Enregistrer
      :action:      le texte au format PostScript
      :mode: command
      :code: :hardcopy > <path/to/file.ps>
      :note: 'En fait, on utilise la commande pour imprimer, qu’on détourne vers un fichier.'
      :tags: print postscript

    -
      :main_action: Fermer
      :action:      le fichier courant sans l’enregistrer
      :mode: normal
      :code: ":q!"
      :memo: "((q))uit ((!)) attention : sans sauver"

    -
      :main_action: Fermer
      :action:      le fichier courant en l’enregistrant [dans un autre fichier]
      :mode: command
      :code: :e[xit] [<path/to/file.ext>]
      :note: '`exit`, contrairement à `write`, ne sauve que si le fichier a été changé.'

    -
      :main_action: Fermer
      :action:      le fichier courant en enregistrant un certain rang de lignes dans un autre
      :mode: command
      :code: ':<rang> e[xit] <path/to/file.ext>'
      :exemples:
        - '`:.,.+10 exit ~/mon.txt` => enregistre les dix lignes à partir de la ligne courante dans le fichier `mon.txt` et ferme le fichier.'

    -
      :main_action: Fermer/quitter
      :action:      tous les fichiers
      :mode: normal
      :code: ":qa[ll]"
      :memo: "((q))uit ((a))ll"
      :note: "Ajouter `!` à la fin pour forcer la fermeture sans enregistrer les modifications non enregistrées."

    -
      :main_action: Fermer/quitter
      :action:      tous les fichiers en les enregistrant
      :mode: normal
      :code:
        - ':wqa[ll]'
        - ':xa[ll]'
      :memo: "((w))rite ((q))uit all"

    -
      :main_action: Définir
      :action: "le dossier courant en path et tous ses sous-dossiers"
      :code: ":set path=$PWD/le/dossier/**"
      :memo: "(ne pas oublier les `**` à la fin)"
      :tags: dossier

    -
      :main_action: Rechercher
      :action: "un fichier et l'ouvrir"
      :code: ":find <nom exact du fichier.extension>"
      :memo: "(il faut avoir setté le path avant : `:set path=...`)"

    -
      :main_action: Rechercher
      :action: "un fichier et l'ouvrir en splittant la fenêtre"
      :code: ":sfind <nom exact du fichier.extension>"

    -
      :main_action: Lister
      :action: "dans le buffer courant les fichiers/dossiers courants"
      :mode: normal
      :code: "!!ls"

    -
      :main_action: Comparer
      :action:      deux fichiers
      :code:
        - '$> vimdiff <path/to/file1> <path/to/file2>'
        - '[COMMAND] :vert splitdiff <path/to/file2>'
      :note: Avec la seconde solution, le premier fichier doit être ouvert.
      :tags: comparer diff

    -
      :main_action: Aller
      :action:      à la [xième] différence suivante
      :mode: normal
      :code: '[x] ALT MAJ KeyCrochetF KeyC'

    -
      :main_action: Revenir
      :action:      à la [xième] différence précédente
      :mode: normal
      :code: '[x] ALT MAJ KeyCrochetO KeyC'

    -
      :main_action: Modifier
      :action: "l'autre fichier avec le texte du fichier courant"
      :mode: normal
      :code:
        - KeyD KeyP
        - ':[<range>] diffpu[t] [version à corriger]'
      :memo: ((d))iff ((p))ut
      :tags: diff

    -
      :main_action: Modifier
      :action: "l'autre fichier avec le texte du fichier courant"
      :mode: normal
      :code:
        - KeyD KeyO
        - ':[<range>] diffg[et] [version à corriger]'
      :memo: "((d))iff ((o))btain"
      :tags: diff

    -
      :main_action: Modifier un fichier
      :action: "à l'aide d'un script bash (shell script)"
      :code: "1. Écrire le shell\n2. L'enregistrer (dans change.vim par exemple)\n3. $> vim -es monfichier.ext < change.vim"
      :note: "les options signifient : e = en mode `ex`, qui permet de shell script, s = en mode silencieux, pour ne pas avoir les retours de commande."
      :exemples:
        - "Pour remplacer le mot PHIL par MARION dans plusieurs fichiers :\n1. Enregistrer le code suivant dans le fichier `change.vim` :`:%s/PHIL/MARION/g\n`:write\n:quit`\n2. Écrire un fichier `fichier.txt` avec des PHIL.\n3. Quitter Vim\n4. Taper :\n`$> vim -es fichier.txt < change.vim`\n=> Tous les PHIL sont remplacés par des MARION dans le fichier."

    -
      :main_action: Revenir à la version
      :action: "du fichier un certain temps avant"
      :mode: normal
      :code: ":earlier <temps>"
      :note: "Avec <temps> qui peut être en secondes ([x]s) en minutes ([x]m) ou en heures ([x]h)."
      :exemples:
        - "`:earlier 1h` fait revenir à l'état du fichier une heure plus tôt."

    -
      :main_action: Revenir à la version
      :action: "du fichier un certain temps après (quand :earlier a été utilisé)"
      :mode: normal
      :code: ":later <temps>"
      :note: "Avec <temps> qui peut être en secondes ([x]s) en minutes ([x]m) ou en heures ([x]h)."
      :exemples:
        - "Quand on a joué avant `:earlier 1h` (retour à l'état du fichier 1 heure avant), la commande `:later 1h` fait revenir au dernier état du fichier."


# ---------------------------------------------------------------------
#
#  @@@ MULTI-FICHIERS / MULTI-FILES
#
# ---------------------------------------------------------------------

  MULTI-FICHIERS:

    -
      :main_action: Définir
      :action:      les paths par défaut
      :mode: normal
      :important: true
      :code: ':set path=<path/1>,<path/2>…,<path/N>'
      :values:
        'path/N':
          - '`<dossier>/*` => tous les dossiers du dossier'
          - '`<dossier/**` => toute la hiérarchie du dossier'
          - '`` => le dossier courant (donc on doit avoir deux virgules dans la définition)'
          - '`.` => le dossier du fichier courant (fichier activé au moment de l’opération)'

    -
      :main_action: Définir
      :action:      un dossier au top de la recherche
      :mode: normal
      :code:
        - ':set path ^= <path/to/folder>'
        - ':set path+=<path/to> (?)'
      :exemples:
        - '`:set path ^= ../lib` place le dossier `lib` situé dans le dossier parent du dossier parent dans les paths de recherche.'

    -
      :main_action: Ouvrir
      :action:      plusieurs fichiers dans des buffers
      :code: "$> gvim path/to/file1 path/to/file2"
      :memo: "Ne semble pas fonctionner sur mac par défaut."

    -
      :main_action: Passer
      :action:      au(x) fichier(s) suivants
      :mode: normal
      :code: ':[x]n[ext]'

    -
      :main_action: Passer
      :action:      au(x) fichiers(s) précédents
      :mode: normal
      :code:
        - ':[x]p[previous]'
        - ':[x]MAJ KeyN'

    -
      :main_action: Passer
      :action:      au dernier fichier édité
      :mode: normal
      :code: "CTRL ^"

    -
      :main_action: Passer
      :action: "au premier fichier"
      :mode: normal
      :code: ':first'

    -
      :main_action: Passer
      :action:      au dernier fichier
      :mode: normal
      :code: ':last'

    -
      :main_action: Passer
      :action:      au fichier suivant en enregistrant le courant
      :mode: normal
      :code:
        - ':wn[ext]'
        - ':writen'

    -
      :main_action: Passer
      :action:      au fichier suivant sans enregistrer le courant
      :mode: normal
      :code: ':n[ext]!'

    -
      :main_action: Passer
      :action:      en enregistrement automatique au changement de fichier
      :mode: normal
      :code: ":set autowrite"

    -
      :main_action: Sortir
      :action: "de l’enregistrement automatique au changement de fichier"
      :mode: normal
      :code: ":set noautowrite"

# ---------------------------------------------------------------------
#
#   @@@ BUFFERS
#
# ---------------------------------------------------------------------

  BUFFERS:

    -
      :main_action: Nouveau
      :action:      buffer sans nom (sans fichier)
      :mode: normal
      :code: ':ene[w]'
      :memo: "((e))dit ((ne))w"

    -
      :main_action: Afficher
      :action:      la liste des buffers
      :mode: normal
      :code:
        - ':ls'
        - ':buffers'
        - ':files'
      :memo: "((l))i((s))t"

    -
      :main_action: Activer
      :action:      le buffer précédent de la fenêtre courante
      :mode: command
      :code: :b#
      :important: true

    -
      :main_action: Activer
      :action:      un buffer quelconque
      :mode: normal
      :code: ":b CTRL KeyD\n=> La liste des buffers s'affiche"
      :memo: ((d))étail

    -
      :main_action: Activer
      :action:      le [xième] buffer suivant
      :mode: normal
      :code:
        - ':[x ]bn'
        - ':b[x ]next'
      :memo: ((b))uffer ((n))ext

    -
      :main_action: Activer
      :action:      le [xième] buffer précédent
      :mode: normal
      :code: ':[x ]bp[rev]'
      :memo: ((b))uffer

    -
      :main_action: Activer
      :action:      le [xième] buffer modifié [en splitant]
      :mode: normal
      :code: ":[s]bmodified [x]"
      :memo: ((b))uffer

    -
      :main_action: Activer
      :action:      le premier buffer
      :mode: normal
      :code:
        - ':bf[irst]'
        - ':br[ewind]'
      :memo: ((b))uffer

    -
      :main_action: Activer
      :action:      le dernier buffer
      :mode: normal
      :code: ':bl[ast]'
      :memo: ((b))uffer

    -
      :main_action: Activer
      :action:      un buffer par son numéro (dans la fenêtre active)
      :mode: normal
      :code: ":b[uffer] <numéro>"
      :note: 'On peut jouer `:ls` avant pour obtenir la liste des buffers avec leur numéro.'
      :memo: "((b))uffer"

    -
      :main_action: Activer
      :action:      un buffer en splitant horizontalement la fenêtre
      :mode: normal
      :code: ":sb[uffer] <désignation buffer>"
      :tags: split

    -
      :main_action: Activer
      :action:      un buffer en splitant verticalement la fenêtre
      :mode: normal
      :code: ":vert[ical] :sb[uffer] <désignation buffer>"
      :tags: split

    -
      :main_action: Activer
      :action:      un buffer par le nom du fichier/path dans la fenêtre active
      :mode: normal
      :code: ":b <bout du nom>"
      :memo: "((b))uffer"

    -
      :main_action: Ouvrir
      :action:      tous les buffers dans des fenêtres
      :mode: normal
      :code:
        - 'ba[ll]'
        - 'sba[ll]'
    -
      :main_action: Ajouter
      :action:      un buffer (un fichier) à la liste, sans l’ouvrir
      :mode: normal
      :code: ":bad[d] +&gt;num ligne> <path/to/file>"
      :memo: "((b))uffer ((ad))d (ajouter)"

    -
      :main_action: Masquer
      :action:      le buffer courant
      :mode: normal
      :code: ":hid[e]"

    -
      :main_action: Supprimer
      :action:      le buffer courant
      :mode: normal
      :code: ':bd[elete]'
      :memo: ((b))uffer ((d))elete

    -
      :main_action: Supprimer
      :action:      le buffer courant sans enregistrer
      :mode: normal
      :code: ":bd!"
      :memo: ((b))uffser ((d))elete


# ---------------------------------------------------------------------
#
#  @@@ DÉPLACEMENTS (mark "d")
#
# ---------------------------------------------------------------------

  DÉPLACEMENTS:

    -
      :main_action: Mettre un signet (mark)
      :action:      sur la ligne courante.
      :mode: normal
      :code: 'm[ark] <lettre>'

    -
      :main_action: Mettre un signet (mark)
      :action:      sur une ligne pour son numéro.
      :mode: command
      :code:
        - ':<numéro ligne> m[ark] <lettre>'
        - ':<numéro ligne> KeyK<lettre>'
      :note: 'Avec KeyK, on n’est pas obligé de laisser une espace avant la lettre du registre.'

    -
      :main_action: Déplacer
      :action:      plusieurs lignes à une ligne précise
      :mode: command
      :code: ':<range> move <ligne before>'
      :exemples:
        - '`:2,4 move 9` => déplace les lignes de 2 à 4 (comprise) APRÈS la 9<sup>e</sup> ligne.'
        - '`:.,.+2 move 10` => Si la ligne courante (.) est la 5e, copie les lignes 5 à 7 après la ligne 10.'
      :important: true


    -
      :main_action: Retourner
      :action:      à une position précédente
      :mode: normal
      :code: ":ju[mps] => Choisir la destination"

    -
      :main_action: Retourner
      :action:      à la position précédente (jump)
      :mode: normal
      :code: "CTRL KeyO"

    -
      :main_action: Retourner
      :action:      à la position suivante
      :mode: normal
      :code: TAB

    -
      :main_action: Retourner
      :action:      au dernier changement
      :mode: normal
      :code: "g;"
      :note: "On peut avoir la liste des changements avec `:changes`."
      :important: true

    -
      :main_action: Retourner
      :action:      au xième changement
      :mode: normal
      :code: "[x]g, (KeyG KeyVirgule)"
      :note: "On peut avoir la liste des changements avec `:changes`."

    -
      :main_action: Aller
      :action:      au début du document
      :mode: normal
      :code: "KeyGKeyG"
      :memo: ((g))o
      :tags: document

    -
      :main_action: Aller
      :action:      au mot suivant
      :mode: normal
      :code: "[x]KeyW"
      :memo: ((w))ord
      :tags: mot

    -
      :main_action: Aller
      :action:      à la fin du mot suivant
      :mode: normal
      :code: "[x]KeyE"
      :memo: "((e))nd"
      :tags: mot
      :important: true

    -
      :main_action: Aller
      :action:      à la fin du [xième] mot précédent
      :mode: normal
      :code: "[x]KeyGKeyE"
      :memo: "((e))nd"
      :tags: mot

    -
      :main_action: Aller
      :action:      au début de la ligne « écran » suivante
      :mode: normal
      :code: "KeyG KeyJ"
      :note: "La ligne « écran » correspond à la nouvelle ligne qu'on voit à l'écran, mais qui appartient peut-être à la même « ligne texte » que la ligne écran précédente."

    -
      :main_action: Aller
      :action:      au début de la « ligne texte » suivante
      :mode: normal
      :code: KeyJ
      :note: "Cf. la note concernant la commande précédente"

    -
      :main_action: Régler les options
      :action:      pour que les touches H, M, L, G et CTRL-END (?) retourne au début de la ligne
      :mode: command
      :code: ':set [no]startofline'

    -
      :main_action: Aller
      :action:      au début de la « ligne texte » précédente
      :mode: normal
      :code: KeyK

    -
      :main_action: Aller
      :action:      au début de la « ligne écran » précédente
      :mode: normal
      :code: KeyG KeyK

    -
      :main_action: Aller
      :action:      au début de la [xième] phrase suivante
      :mode: normal
      :code: "[x])"
      :note: "Les phrases sont reconnues grâce aux ponctuations : . (point), ! (point d'exclamation) ? (point d'interrogation). Le point-virgule n'est pas concerné."

    -
      :main_action: Aller
      :action:      au début du [xième] paragraphe suivant
      :mode: normal
      :code: "[x]} ou [x]+"

    -
      :main_action: Aller
      :action:      au début de la [xième] phrase précédente
      :mode: normal
      :code: "[x]( ou [x]-"

    -
      :main_action: Aller
      :action:      au début du [xième] paragraphe précédent
      :mode: normal
      :code: "[x]{"

    -
      :main_action: Aller
      :action:      au mot précédent
      :mode: normal
      :code: "[x]KeyB "
      :memo: ((b))ackard
      :important: true
      :tags: mot

    -
      :main_action: Aller
      :action:      à la ligne <i>num</i>
      :mode: normal
      :code:
        - ':<numéro ligne>'
        - '<numéro ligne> MAJ KeyG'
        - '<numéro ligne> KeyGKeyG'
      :memo: ((g))o
      :tags: ligne
      :important: true

    -
      :main_action: Aller
      :action:      à la première ligne de l’écran affiché
      :mode: normal
      :code: "MAJ KeyH"
      :memo: "((H))igh"

    -
      :main_action: Aller
      :action:      à la [x]ième ligne de l’écran actuel
      :mode: normal
      :code: "[x]MAJ KeyH"

    -
      :main_action: Aller
      :action:      à la dernière ligne de l’écran actuel
      :mode: normal
      :code: "MAJ KeyL"
      :memo: "((L))ast ou ((L))ow"

    -
      :main_action: Aller
      :action:      'à la [x]ième dernière ligne de l’écran actuel (en partant du bas)'
      :mode: normal
      :code: "[x] MAJ KeyL"
      :memo: "((L))ast ou ((L))ow"

    -
      :main_action: Aller
      :action:      à la fin de la ligne
      :mode: normal
      :code: '$'
      :memo: Comme dans les expressions régulières
      :important: true
      :tags: ligne

    -
      :main_action: Aller
      :action:      au premier caractère non blanc de la ligne
      :mode: normal
      :code: "^"
      :memo: Comme expressions régulières
      :important: true
      :tags: lettre

    -
      :main_action: Aller
      :action:      au début de la ligne
      :mode: normal
      :code: '0'
      :important: true
      :tags: ligne

    -
      :main_action: Aller
      :action:      à la fin de la xième ligne après la courante
      :mode: normal
      :code: "<nombre lignes>KeyDollar"
      :tags: ligne

    -
      :main_action: Aller
      :action:      au début du paragraphe précédent
      :mode: normal
      :code: "-"
      :memo: "-/+ pour les paragraphes"
      :tags: paragraphe

    -
      :main_action: Aller
      :action:      au début du paragraphe suivant
      :mode: normal
      :code: '+'
      :memo: "-/+ pour les paragraphes"
      :tags: paragraphe

    -
      :main_action: Aller
      :action:      au début du paragraphe suivant
      :mode: normal
      :code: 'CTRL KeyJ'

    -
      :main_action: Aller
      :action:      à l’autre bout de la sélection
      :mode: visual
      :code: KeyO

    -
      :main_action: Aller
      :action:      à la première occurrence du mot sous le curseur
      :mode: normal
      :code: "[CTRL KeyI\nDonc: MAJ ALT 5, KeyI"

    -
      :main_action: Aller
      :action:      à l’occurrence suivante du mot sous le curseur
      :mode: normal
      :code: "]CTRL KeyI\nDonc: MAJ ALT °, KeyI"

    -
      :main_action: Aller
      :action:      à la dernière position du curseur
      :mode: normal
      :code: "''"
      :tags: curseur
      :important: true

    -
      :main_action: Aller
      :action:      au début du dernier insert
      :mode: normal
      :code: "'["
      :memo: "Note : ne semble pas fonctionner (sur mac)"
      :tags: curseur

    -
      :main_action: Aller
      :action:      au premier (ou xième) caractère suivant voulu
      :mode: normal
      :code: "[x]f<caractère>"
      :memo: ((f))ind
      :tags: lettre

    -
      :main_action: Aller
      :action:      juste avant le premier [ou xième] caractère suivant cherché
      :mode: normal
      :code: "[x]t<car>"
      :memo: "'((t))il (until)"
      :tags: lettre

    -
      :main_action: Aller
      :action:      au premier [ou xième] caractère précédent voulu
      :mode: normal
      :code: "[x]MAJ KeyF<car>"
      :memo: f/F pour find avant/arrière
      :tags: lettre

    -
      :main_action: Aller
      :action:      juste avant le premier [ou xième] caractère précédent voulu
      :mode: normal
      :code: "[x]MAJ t<car>"
      :memo: "t/T pour until avant/arrière"
      :tags: lettre

    -
      :main_action: Aller
      :action:      un demi-écran plus le bas
      :mode: normal
      :code: "CTRL KeyD"
      :memo: "((d))own"
      :tags: écran

    -
      :main_action: Aller
      :action:      à l’écran suivant
      :mode: normal
      :code: 'CTRL KeyF'
      :tags: écran
      :important: true

    -
      :main_action: Aller
      :action:      un demi-écran vers le haut
      :mode: normal
      :code: "CTRL KeyU"
      :memo: "((u))p"
      :tags: écran

    -
      :main_action: Aller
      :action:      à la fin du document
      :mode: normal
      :code: "MAJ KeyG"
      :memo: ((G))o
      :tags: document

    -
      :main_action: Aller
      :action:      à un certain pourcentage du document
      :mode: normal
      :code: '<x>%'
      :exemples: "`50%` se rend à la moitié du document."
      :tags: document

    -
      :main_action: Aller
      :action:      à l’élément paire (précédent/suivant)
      :mode: normal
      :code: "% (MAJ ù)"
      :tags: pairs

    -
      :main_action: Définir
      :action:      les caractères formant des paires
      :mode: normal
      :code: ':set matchpairs=<in>:<out>,<in>:<out>,etc.'
      :exemples:
        - '`:set matchpairs=(:),[:],{:},<:>`'
      :tags: pairs

    -
      :main_action: Ajouter
      :action:      une paire de caractères
      :mode: normal
      :code: ':set matchpairs+=<in>:<out>'
      :exemples:
        - '`:set matchpairs+=<:>` ajoute la paire "<" et ">".'
      :tags: pairs

    -
      :main_action: Définir
      :action: "le comportement du curseur en début et fin de ligne"
      :code: ":set whichwrap=<lettre>"

# ---------------------------------------------------------------------
#
#   @@@ MARQUES / MARKS
#
# ---------------------------------------------------------------------

  MARQUES:

    -
      :main_action: Supprimer
      :action: 'toutes les marques'
      :mode: normal
      :code: ':delmarks'

    -
      :main_action: Bloquer
      :action: 'les marques avant modification du fichier'
      :mode: normal
      :code: ':lockmarks'

    -
      :main_action: Conserver
      :action: 'les marques avant modification du fichier'
      :mode: normal
      :code: ':keepmarks'
      :note: 'Contrairement à `lockmarks`, qui ne raccourcit pas le fichier, ici, le fichier peut être raccourci et les marques des lignes supprimées sont supprimées elles-aussi.'

    -
      :main_action: Afficher
      :action: "toutes les marques définies"
      :mode: normal
      :code: ":marks"
      :tags: mark

    -
      :main_action: Afficher
      :action: "les informations sur une marque en particulier"
      :mode: normal
      :code: ":marks <lettre>"
      :tags: mark

    -
      :main_action: Définir
      :action: "la marque précédente"
      :mode: normal
      :code: "m'"
      :memo: ((m))ark
      :tags: mark

    -
      :main_action: Placer
      :action: "une marque locale au curseur"
      :mode: normal
      :code: "KeyM <a-z>"
      :memo: "((m))arque"
      :note: "La marque est « locale », c'est-à-dire qu'elle est propre au fichier/buffer et qu'elle ne peut pas être rejointe depuis un autre endroit que le fichier."
      :tags: mark curseur

    -
      :main_action: Placer
      :action: "une marque globale au curseur"
      :mode: normal
      :code: "KeyM <A-Z>"
      :memo: "((m))arque"
      :note: "La marque est « globale », c'est-à-dire qu'on peut l'atteindre même depuis un autre fichier/une autre fenêtre."
      :tags: mark fichier

    -
      :main_action: Aller
      :action: "à une marque définie"
      :mode: normal
      :code:
        - "'<a-zA-Z>"
        - "`<a-zA-Z>"
      :memo: "\"'\" se rend au début de la ligne\n\"`\" se rend à la ligne/colonne de la marque."
      :tags: mark

# ---------------------------------------------------------------------
#
#   @@@ SÉLECTION/SELECT
#
# ---------------------------------------------------------------------

  SÉLECTION:


    -
      :main_action: Sélectionner
      :action:      plusieurs lignes entières
      :mode: normal
      :code: "MAJ KeyV KeyJ/KeyK"
      :memo: V majuscule bascule en mode visuel par ligne.

    -
      :main_action: Sélectionner
      :action:      '(pour copier) une grande portion de texte'
      :mode: normal
      :code: "1. Placer une marque au début (mz)\n2. se rendre à la fin de la portion\n3. taper `d'z`"

    -
      :main_action: Sélectionner
      :action:      en mode block-visual
      :code: CTRL KeyV

    -
      :main_action: Sélectionner
      :action:      le mot sous le curseur et l’espace suivante
      :mode: visual
      :code: KeyA KeyW

    -
      :main_action: Sélectionner
      :action:      le mot sous le curseur et seulement le mot
      :mode: visual
      :code: KeyI KeyW
      :memo: '((i))nner word'

    -
      :main_action: Sélectionner
      :action:      la phrase sous le curseur et l’espace suivante
      :mode: visual
      :code: KeyA KeyS
      :memo: '((s))entence, phrase'

    -
      :main_action: Sélectionner
      :action:      la phrase sous le curseur sans l’espace suivante
      :mode: visual
      :code: KeyI KeyS
      :memo: '((i))nner ((s))entence'

    -
      :main_action: Sélectionner
      :action:      le paragraphe sous le curseur et l’espace suivante
      :mode: visual
      :code: KeyA KeyP
      :memo: '((p))aragraphe'

    -
      :main_action: Sélectionner
      :action:      le paragraphe sous le curseur sans l’espace suivante
      :mode: visual
      :code: KeyI KeyP
      :memo: '((i))nner ((p))aragraph'

    -
      :main_action: Sélectionner
      :action:      le texte entre parenthèses et les parenthèses
      :mode: visual
      :code:
        - 'KeyA ('
        - 'KeyA )'
        - 'KeyA KeyB'

    -
      :main_action: Sélectionner
      :action:      le texte entre parenthèses sans les parenthèses
      :mode: visual
      :code:
        - 'KeyI ('
        - 'KeyI )'
        - 'KeyI KeyB'

    -
      :main_action: Sélectionner
      :action:      le texte sous le curseur entre `<` et `>`
      :mode: visual
      :code:
        - 'KeyA <'
        - 'KeyA >'

    -
      :main_action: Sélectionner
      :action:      le texte sous le curseur entre les `<...>` sans les `<` et `>`
      :mode: visual
      :code:
        - 'KeyI <'
        - 'KeyI >'

    -
      :main_action: Sélectionner
      :action:      le texte sous le curseur entre `{`/`}`, `[`/`]`, `'`/`'`, etc. avec les signes et l’espace suivante.
      :mode: visual
      :code: 'KeyA [signe]'
      :exemples:
        - '`KeyA {` sélectionne tout ce qui est entre les crochets avec les crochets'

    -
      :main_action: Sélectionner
      :action:      le texte sous le curseur entre `{`/`}`, `[`/`]`, `'`/`'`, etc. sans les signes.
      :mode: visual
      :code: 'KeyI [signe]'
      :exemples:
        - '`KeyI "` sélectionne tout ce qui est entre guillemets sans les guillemets.'

    -
      :main_action: Sélectionner
      :action:      le texte entre deux tags XML avec les tags.
      :mode: visual
      :code: 'KeyA KeyT'
      :memo: '((t))ag'
      :exemples:
        - "Avec &lt;div>Mon texte.&lt;/div>, sélectionne `&lt;div>Mon texte.&lt;/div>`"

    -
      :main_action: Sélectionner
      :action:      le texte entre deux tags XML sans les tags.
      :mode: visual
      :code: 'KeyI KeyT'
      :memo: '((i))nner ((t))ag'
      :exemples:
        - "Avec &lt;div>Mon texte.&lt;/div>, sélectionne `Mon texte.`"

    -
      :main_action: Déplacer le curseur
      :action:      d’un bout à l’autre de la sélection
      :mode: visual
      :code: KeyO

    -
      :main_action: Resélectionner
      :action: la sélection visuelle précédente
      :mode: visual
      :code: 'KeyG KeyV'
      :note: Bascule entre la sélection courante et la précédente

    -
      :main_action: Passer en mode
      :action:      sélection de caractère
      :mode: normal
      :code: KeyG KeyH
      :note: Attention, le déplacement ne peut plus se faire avec lettres.

    -
      :main_action: Passer en mode
      :action:      sélection de lignes
      :mode: normal
      :code: KeyG MAJ KeyH

    -
      :main_action: Passer en mode
      :action:      sélection par block
      :mode: normal
      :code: KeyG CTRL KeyH

# ---------------------------------------------------------------------
#
#   @@@ TEXTE
#
# ---------------------------------------------------------------------

  TEXTE:

    -
      :main_action: Jouer une commande
      :action:      sur toutes les lignes correspondant à une pattern
      :important: true
      :mode: command
      :code: ':g[lobal][!] /<reg exp>/ <commande>'
      :exemples:
        - '`:global ,^La, delete` => Efface (`delete`) toutes les lignes qui commencent (`^`) par « La ».'
        - '`:global! ,^La, delete` => Efface (`delete`) toutes les lignes qui ne commencent pas (`!` et `^`) par « La ».'
        - '`:g ,Marion, print` => imprime toutes les lignes contenant « Marion »'

    -
      :main_action: Jouer une commande
      :action:      sur toutes les lignes ne correspondant pas à une pattern
      :mode: command
      :code:
        - ':global! ...'
        - ':vglobal ...'
      :note: 'Voir la commande précédente.'

    -
      :main_action: Insérer
      :action:      le texte du presse-papier système
      :mode: normal
      :code: ":set paste, CMD KeyV, :set nopaste"
      :note: "En fait, ça a l'air de fonctionner aussi avec CMD KeyV normalement."

    -
      :main_action: Insérer
      :action:      le contenu d’un fichier [après une ligne]
      :mode: command
      :code: ':[line]read <path/to/the/file.ext>'
      :notes: 'Si aucune ligne n’est spécifié, ajoute après la ligne courante. Si aucun fichier n’est spécifié, ajoute après le fichier courant.'

    -
      :main_action: Insérer
      :action:      le résultat d’une commande à la ligne courante [ou après une certaine ligne]
      :mode: command
      :code:
        - ':[line]read !<commande>'
        - ':r!<commande>'
      :exemples:
        - '`:4 read !echo "Bonjour"` => écrit « Bonjour » après la 4e ligne.'
        - '`r!ls` => écrit les fichiers du dossier courant dans la fenêtre courante'

    -
      :main_action: Insérer
      :action:      'le contenu d’un registre (en mode insertion)'
      :mode: insert
      :code: "CTRL KeyR <a-z du registre>"
      :note: "En répétant `CTRL KeyR`, on insert le contenu sans interprétation des caractères spéciaux tels que `<BS>`."

    -
      :main_action: Insérer
      :action:      une nouvelle ligne sous la ligne courante et passer en édition
      :mode: normal
      :code: KeyO
      :memo: ((o))pen up new line

    -
      :main_action: Insérer
      :action:      une nouvelle ligne au-dessus de la ligne courante et passer en édition
      :mode: normal
      :code: MAJ KeyO
      :memo: ((O))pen up new line

    -
      :main_action: Insérer
      :action:      des lignes à partir d’une certaine ligne en mode commande.
      :mode: command
      :code: ":<index ligne 0-start> a[ppend] ENTER\n Ligne 1 ENTER\n Ligne 2 ... Ligne N ENTER\n KeyPoint ENTER"
      :exemples:
        - "`:0 a\nUne nouvelle ligne\n.\n` => Ajoute « Une nouvelle ligne » tout en haut du fichier."
      :important: true

    -
      :main_action: Insérer
      :action:      des lignes à partir d’une certaine ligne en mode commande.
      :mode: command
      :code: ":<index ligne 1-start> i[nsert] ENTER\nLignes ...\nKeyPoint ENTER\n"
      :note: "Je mets « 1-start » mais en fait il faut comprendre que `append` ajoute au bout de la ligne et que `insert` insert avant."

    -
      :main_action: Stopper
      :action:      le mode insertion introduit par `insert`
      :mode: command
      :code: ':stopinsert'
      :exemples:
        - '`:autocmd BufEnter * :stopinsert`'
      :note: 'C’est surtout utile quand on programme des commandes.'

    -
      :main_action: Insérer
      :action:      du texte APRÈS le caractère courant
      :mode: normal
      :code: KeyA
      :memo: ((a))ppend ((a))fter

    -
      :main_action: Insérer
      :action:      du texte AVANT le caractère courant
      :mode: normal
      :code: KeyI
      :memo: ((i))nsert

    -
      :main_action: Insérer
      :action:      du texte à la fin de la ligne
      :mode: normal
      :code: MAJ KeyA
      :memo: ((A))ppend
      :tags: ligne

    -
      :main_action: Insérer
      :action:      du texte au début de la ligne
      :mode: normal
      :code: "MAJ KeyI<texte>"
      :note: "Passe en mode INSERT après la touche KeyI"

    -
      :main_action: Insérer
      :action:      'un caractère spécial (digraphs)'
      :mode: insert
      :code: "CTRL KeyK <2 lettres du digraph>"
      :memo: Spécial ((k))aractère
      :note: "Voir aussi CTRL KeyV plus bas."
      :exemples:
        - "Taper `:digraphs` pour voir la liste."
      :tags: digraph

    -
      :main_action: Insérer
      :action:      plusieurs fois le même caractère
      :mode: normal
      :code: "<fois>KeyI<signe> ESC"
      :exemples:
        - "`80i- ESC` insert 80 tiret au curseur"
      :note: "Il faut bien utiliser la touche ESC et non pas CTRL KeyC pour quitter le mode."

    -
      :main_action: Insérer
      :action:      n’importe quel caractère tel quel.
      :mode: insert
      :code: CTRL KeyV <signe>
      :note: 'Ça concerne aussi bien les retours chariot que les tabulations.'

    -
      :main_action: Insérer
      :action:      le texte du presse-papier après le caractère courant
      :mode: normal
      :code: '[x]KeyP'
      :memo: ((p))aste

    -
      :main_action: Insérer
      :action: le texte du presse-papier AVANT le caractère suivant
      :mode: normal
      :code: "[x] MAJ KeyP"
      :memo: ((p))aste

    -
      :main_action: Insérer
      :action: la date au curseur
      :mode: normal
      :code: "!!date"
      :tags: date

    -
      :main_action: Insérer
      :action: 'une expression arithmétique (registre expression "=) ou une fonction/opérateur Vim'
      :mode: normal
      :code: '"=<expression> ENTER KeyP'
      :exemples:
        - '`"=12*12 ENTER KeyP` insert « 144 » au curseur'
        - '`"=$HOME ENTER KeyP` colle au curseur le chemin vers home'
        - '`"=$PWD ENTER KeyP` colle au curseur le chemin vers le dossier racine courant.'

    -
      :main_action: Insérer
      :action: le même texte sur plusieurs lignes
      :mode: "visual-block"
      :code: "(CTRL KeyV) sélectionner les lignes, MAJ KeyI, taper le texte, ESC"
      :exemples:
        - "Si on utilise CTRL KeyC au lieu d'ESC pour terminer, ça ne fonctionne pas."

    -
      :main_action: Insérer
      :action: "des espaces sur plusieurs lignes"
      :mode: "visual-block"
      :code: "(CTRL KeyV) sélectionner les lignes, >, MAJ ; pour augmenter"
      :exemples:
        - "Pour supprimer ces espaces, utiliser `<`"

    -
      :main_action: Insérer
      :action: "n'importe quel caractère par son numéro ASCII ou hexa"
      :mode: insert
      :code: "CTRL KeyV <nombre>"
      :exemples:
        - "`i` pour passer en mode INSERT, `CTRL KeyV 123` => insert le caractère « { »"
        - "`i` pour mode INSERT, `CTRL KeyV x7b` insert le caractère « { »."

    -
      :main_action: Afficher
      :action: "tous les caractères spéciaux"
      :mode: normal
      :code: ":digraphs"

    -
      :main_action: Afficher
      :action: "les informations sur le caractère sous le curseur"
      :mode: normal
      :code: ":ascii"

    -
      :main_action: Afficher
      :action: des informationssur la position courante
      :mode: normal
      :code: "KeyG CTRL KeyG"
      :note: "Affiche la colonne/nombre de colonnes, la ligne/nombre de lignes, le mot/nombre de mots, la caractère/nombre de caractères, le byte, nombre de bytes."

    -
      :main_action: Modifier
      :action:      le texte en le remplaçant
      :mode: normal
      :code: "KeyC[w|cKeyDollar]"
      :memo: "((c))hange"
      :exemples:
        - "[NORMAL] KeyCKeyW => [INSERT] <nouveau texte>"
        - "[NORMAL] KeyV [VISUAL] KeyE KeyC [INSERT] => change le mot"

    -
      :main_action: Modifier
      :action:      toute la ligne (même si on n’est pas placé au début)
      :mode: normal
      :code: "KeyCKeyC"

    -
      :main_action: Modifier
      :action:      depuis le curseur jusqu’à la fin de la ligne
      :mode: normal
      :code:
        - KeyCKeyDollar
        - MAJ KeyC
      :memo: "Comme `KeyDKeyDollar` mais passe en édition."

    -
      :main_action: Modifier
      :action:      le caractère courant (et les x suivants)
      :mode: normal
      :code: "[x]KeyR<car>"
      :memo: "((r))eplace"

    -
      :main_action: Modifier
      :action:      la casse du caractère courant (et les x suivants)
      :mode: normal
      :code: "[x]~ (ALT KeyN SPACE)"

    -
      :main_action: Modifier
      :action:      la casse de toute la ligne courante
      :mode: normal
      :code: "KeyG ~ ~\nDonc : KeyG ALT KeyN SPACE ALT KeyN SPACE"

    -
      :main_action: Passer le texte en capitales
      :action:      jusqu’à la motion définie
      :mode: normal
      :code: "KeyG MAJ KeyU <motion>"
      :exemples:
        - "Pour modifier depuis le curseur jusqu'à la fin de la ligne : `KeyG MAJ KeyU KeyDollar`"

    -
      :main_action: Passer le texte en minuscules
      :action:      jusqu’à la motion définie
      :mode: normal
      :code: "KeyG KeyU <motion>"
      :exemples:
        - "Mettre en minuscules depuis le curseur jusqu'à la fin de la ligne : `KeyG KeyU KeyDollar`"

    -
      :main_action: Encrypter/décrypter
      :action:      le texte sélectionner
      :mode: visual
      :code: 'KeyG MAJ KeyInterro'
      :note: Utilise l’encodange <em>Rot13</em>

    -
      :main_action: Incrémenter
      :action: "[de x] le nombre sous le curseur"
      :mode: normal
      :code: "[x]CTRL KeyA"
      :note: "Tient compte de la base : un nombre commençant par 0 est considéré comme octal, un nombre commençant par `0x` est considéré comme hexadécimal"

    -
      :main_action: "[Dés]activer"
      :action: "la correction autographique"
      :mode: normal
      :code: ":set [no]spell"
      :important: true

    -
      :main_action: Définir
      :action: "la langue du texte"
      :mode: normal
      :code: ":set spelllang=fr (ou 'de', etc.)"

    -
      :main_action: Définir
      :action: "sa propre liste de mots corrects"
      :mode: normal
      :code: ":set spellfile=<path/to/file.add[,<path/other/file.add]"
      :note: "L'extension doit obligatoirement être `.add`."

    -
      :main_action: Compiler
      :action: son propre dictionnaire
      :mode: normal
      :code: ":mkspell [-ascii ]<out-file> <in-file>"
      :memo: "((m))a((k))e spell"
      :note: "On ajoute l'option `-ascii` pour dire à vim de passer tous les caractères non-ASCII.\nLe nom des fichiers d'entrée doit respecter la convention `<langue>_<region>` (`fr_FR` pour la France métropolitaine)."

    -
      :main_action: Ajouter
      :action:      un dictionnaire
      :note: "Le télécharger à l'adresse `https://extensions.libreoffice.org/extensions/dictionnaires-francais` par exemple."

    -
      :main_action: Ajouter un mot
      :action:      au dictionnaire personnel
      :mode: normal
      :code: "Placer le curseur sur le mot puis taper KeyZKeyG\nOu[COMMAND]:spellg[ood] <mot>"
      :exemples:
        - "`2KeyZKeyG` => Ajoute le mot sous le curseur au deuxième dictionnaire spécifié."
      :note: "Ajouter un index devant la commande si plusieurs dictionnaires sont spécifiés par `:set spellfile`"

    -
      :main_action: Ajouter un mot
      :action:      correct au dictionnaire volatile (session)
      :mode: normal
      :code:
        - "Placer le curseur sur le mot puis taper `zG` (KeyZ MAJ KeyG)"
        - "[COMMAND]:spellg[ood]! <mot>"

    -
      :main_action: Ajouter un mot
      :action:      erroné au dictionnaire
      :mode: normal
      :code:
        - "Placer le curseur sur le mot puis `zw` (KeyZKeyW)"
        - "COMMAND]:spellw[rong] <mot>"

    -
      :main_action: Ajouter un mot
      :action: "erroné au dictionnaire volatile (session)"
      :mode: normal
      :code:
        - "Placer le curseur sur le mot puis `zw!` (KeyZKeyW!)"
        - "[COMMAND]:spellw[rong]! <mot>"

    -
      :main_action: Annuler
      :action: "l'ajout au dictionnaire"
      :mode: normal
      :code:
        - "Placer le curseur sur le mot puis KeyZKeyUKeyG"
        - "[COMMAND]:spellu[ndo] <mot>"

    -
      :main_action: Annuler
      :action: "l'ajout au dictionnaire volatile (session)"
      :mode: normal
      :code:
        - "Placer le curseur sur le mot puis KeyZKeyUKeyG!"
        - "[COMMAND]:spellu[ndo]! <mot>"

    -
      :main_action: Obtenir
      :action: "des suggestions concernant le mot erroné"
      :mode: normal
      :code: "se placer sur le mot erroné et taper KeyZ="
      :important: true

    -
      :main_action: Définir
      :action: "ce qu'est un mot"
      :mode: normal
      :code: ":set iskeyword=<définition>"
      :note: "La valeur peut être une lettre ou son code ASCII"
      :exemples:
        - "`:set iskeyword=a,e,i,o,u` => les mots seront exclusivement des voyelles.\n`:set iskeyword=a-z` => les mots seront exclusivement les mots minuscules, etc."
      :tags: mot

    -
      :main_action: Affficher
      :action: la liste des mots actuels
      :mode: normal
      :code: ":spelld[ump]"

    -
      :main_action: Afficher
      :action: "la définition de ce qu'est un mot"
      :mode: normal
      :code: ":set iskeyword?"

    -
      :main_action: Aller
      :action:      à l’erreur orthographique suivante
      :mode: normal
      :code: "]s (ALT MAJ °, KeyS)"

    -
      :main_action: Joindre
      :action:      des lignes par leur rang [sans espace]
      :mode: command
      :code: ':<rang> join[!]'
      :exemples:
        - "`:4,6 join` => join les lignes 4, 5 et 6 en les séparant par une espace."
        - "`:4,6 join!` => join les lignes 4, 5 et 6 sans les séparer par une espace."

    -
      :main_action: Joindre
      :action:      'les lignes sélectionnées en mode visuel (espace séparatrice)'
      :mode: visual
      :code: "MAJ KeyJ"
      :memo: ((j))oin

    -
      :main_action: Joindre
      :action:      les lignes sélectionnées sans ajout d’espace
      :mode: visual
      :code: KeyG MAJ KeyJ

    -
      :main_action: Joindre
      :action:      la ou les lignes suivantes à la ligne courante
      :mode: normal
      :code: "[x]MAJ KeyJ"
      :memo: ((j))oin

    -
      :main_action: Supprimer
      :action:      le dernier mot entré avant le curseur
      :mode: insert
      :code: "CTRL KeyW"
      :memo: "((w))ord = mot"
      :important: true
      :note: "Noter qu'il s'agit bien du mot INSERT et pas du mode NORMAL. En mode NORMAL, le raccourci CTRL KeyW permet notamment de switcher entre les fenêtres."

    -
      :main_action: Supprimer
      :action:      la dernière ligne entrée avant le curseur
      :mode: insert
      :code: "CTRL KeyU"
      :note: "Noter qu'il s'agit du mode INSERT."

    -
      :main_action: Supprimer
      :action:      la ligne courante
      :mode: normal
      :code: KeyDKeyD
      :memo: ((d))elete
      :note: 'Elle est mémorisée dans le registre par défaut et peut être pastée à l’aide de KeyP.'

    -
      :main_action: Supprimer
      :action:      la ligne courante en la mémorisant dans un buffer
      :mode: normal
      :code: "\"[a-Z] KeyDKeyD"
      :memo: "`\"` pour indiquer le buffer, de a à z et A à Z"

    -
      :main_action: Supprimer
      :action:      jusqu’à la fin du mot courant ou du xième mot
      :mode: normal
      :code:
        - KeyDKeyW
        - 'KeyD[x]KeyW'
      :memo: "((d))elete ((w))ord"
      :exemples:
        - "\"c'est un ant<sel>i</sel>dote pour les\", KeyDKeyW => \"c'est un ant pour les\""
        - "\"c'est un <sel>a</sel>ntidote pour les\", KeyDKeyW => \"c'est un pour les\" (le mot complet supprimé)"
        - "\"c'est <sel>u</sel>n antidote pour les\", KeyD3KeyW => \"c'est les\" (trois mots supprimés)"

    -
      :main_action: Supprimer
      :action:      jusqu’à la fin de la ligne
      :mode: normal
      :code:
        - KeyDKeyDollar
        - MAJ KeyD
      :memo: "KeyDollar = fin de ligne"

    -
      :main_action: Supprimer
      :action:      jusqu’à la fin de la ligne et passer en insertion
      :mode: normal
      :code: MAJ KeyC
      :memo: "((C))hange"

    -
      :main_action: Supprimer
      :action:      en mode visuel
      :mode: normal
      :code: KeyV [VISUAL] <move> KeyD"

    -
      :main_action: Supprimer
      :action:      jusqu’à un certain caractère
      :mode: normal
      :code: "df> (utiliser . pour répéter)"

    -
      :main_action: Supprimer/yanker
      :action:      une ligne par son numéro [et la placer dans un registre]
      :mode: command
      :code: ':<numéro ligne>delete [registre]'
      :note: 'Si le registre est Majuscule, la commande ajoute le texte au texte présent dans le registre minuscule.'
      :exemples:
        - '`:5delete` => supprime la ligne 5.'
        - '`:6delete z` => supprime la ligne 6 en plaçant son contenu dans le registre "z".'
        - '`:7delete Z` => supprime la ligne 7 en AJOUTANT son contenu au registre "z".'

    -
      :main_action: Supprimer/yanker
      :action:      des lignes à partir d’un numéro et pour un certain compte [en les plaçant dans un registre]
      :mode: normal
      :code: ':<ligne from> delete [registre] <nombre ligne>'
      :note: 'Si le registre est majuscule, on AJOUTE le contenu des lignes au registre.'
      :exemples:
        - '`:4 delete 10` => efface 10 lignes à partir de la 4e comprise'
        - '`:2 delete s 4` => efface 4 lignes à partir de la 2 et place leur contenu dans le registre "s"'
        - '`:10 delete S 2` => efface 2 lignes à partir de la 10e et AJOUTE leur contenu au registre "s"'
      :important: true

    -
      :main_action: Supprimer/yanker
      :action:      un rang de lignes [en l’insérant dans un registre]
      :mode: command
      :code: ':<range> delete [registre]'
      :note: 'Si le registre est une capitale, c’est un ajout au texte existant qu’il faut faire.'
      :exemples:
        - '`:1,3 delete a` => supprime les lignes 1 à 3 en en mettant le contenu dans le registre "a"'
        - '`:4,5 delete A` => supprime les lignes 4 à 5 en AJOUTANT leur contenu au registre "a"'

    -
      :main_action: Supprimer/yanker
      :action:      des lignes en spécifiant un mot qu’elles contiennent [et placer le contenu dans un registre].
      :mode: command
      :code: ':/<mot ligne de>/, /<mot ligne à>/ delete [registre]'
      :exemples:
        - '`: /depuis/, /jusqu’à/ delete w` => efface les lignes depuis la ligne contenant "depuis" jusqu’à la ligne contenant "jusqu’à" et met le contenu dans le registre "w".'
        - '`:/de/, /à/ delete W` => ajoute depuis la ligne contenant "de" jusqu’à la ligne contenant "à" au registre "w" en supprimant les lignes.'
      :note: 'Si le `<mot ligne à>` se trouve avant le `<mot ligne de>`, la commande ne produit rien.'

    -
      :main_action: Supprimer/yanker
      :action:      des lignes en spécifiant un mot contenu dans une ligne précédente ou suivante
      :mode: command
      :code: ':/mot de/<+|-><nombre lignes>, /mot à/<+|-><nombre lignes> delete [registre]'

    -
      :main_action: Supprimer/yanker
      :action:      des lignes en spécifiant plusieurs mots recherchés à la suite
      :mode: command
      :code: ':/mot 1/ /mot puis/ /autre mot puis.../, /mot 2/ /mot puis/ delete [registre]'

    -
      :main_action: Supprimer/yanker
      :action:      des lignes en précisant à quelle ligne commencer la recherche par mot
      :mode: command
      :code: ':[<numéro ligne>]/mot de/, [<numéro ligne>]/mot à/ delete [registre]'
      :exemples:
        - '`:7/Marion/, 8/Phil/ delete R` => Efface depuis la première ligne contenant "Marion" à partir de la ligne 7, jusque la ligne contenant "Phil" en ajoutant ces lignes au registre "r".'
      :note: 'Attention de s’assurer que le second mot se trouve bien après le premier.'

    -
      :main_action: Yanker
      :action:      une portion de texte
      :mode: normal
      :code:
        - KeyY
        - KeyYKeyM
        - KeyYKeyY
        - etc.
      :memo: "((y))ank"
      :note: 'On fait la distinction entre « yanker », qui mémorise un texte et « copier » qui ajoute un texte au texte.'

    -
      :main_action: Yanker
      :action:      la ligne courante dans le registre par défaut
      :mode: normal
      :code: KeyYKeyY
      :memo: "((y))ank"
      :note: 'On fait la distinction entre « yanker », qui mémorise un texte et « copier » qui ajoute un texte au texte.'
      :important: true

    -
      :main_action: Yanker
      :action:      un rang de lignes [dans un registre] (en mode commande)
      :mode: command
      :code: ':<rang> yank[ <lettre registre>]'
      :exemples:
        - '`:1,4 yank` => copie les lignes 1 à 4 dans le registre sans nom.'
        - '`:5,$ yank f` => copie les lignes depuis la 5 jusqu’à la fin dans le registre « f ».'

    -
      :main_action: Yanker
      :action:      du curseur à la fin de la ligne dans le registre par défaut
      :mode: normal
      :code: KeyYKeyDollar

    -
      :main_action: Yanker
      :action:      depuis le curseur jusqu’au début de la ligne
      :mode: normal
      :code:
        - KeyY0
        - 'KeyY^'

    -
      :main_action: Yanker
      :action:      depuis le curseur jusqu’à une marque
      :mode: normal
      :code: "1. Placer la marque (m<a-Z>)\n2. Se déplacer à l'endroit voulu.\n3. `y'<a-Z>`"

    -
      :main_action: Yanker
      :action:      le mot courant dans le registre par défaut
      :mode: normal
      :code: "KeyYKeyW"

    -
      :main_action: Yanker
      :action:      plusieurs lignes
      :mode: normal
      :code: "[x]KeyY"
      :memo: "p.e. `3y`"

    -
      :main_action: Copier
      :action:      plusieurs lignes à un endroit du texte.
      :note: 'On fait bien la différence, ici, entre « yanker » (qui ne fait <em>que</em> mémoriser le texte) et « copier » (qui <em>ajoute</em> le texte au texte).'
      :mode: command
      :code: ':<range> copy <ligne before>'
      :exemples:
        - '`:2,4 copy 9` => yank le contenu des lignes de 2 à 4 (comprise) et le colle APRÈS la 9<sup>e</sup> ligne.'

    -
      :main_action: Enregistrer
      :action:      un bout du texte dans un fichier
      :mode: visual
      :code: "sélectionner le texte puis `:write <path/to/file.ext>`"
      :note: "La commande prévient si un fichier existe déjà. Pour l'écraser, ajouter `!` à la fin de la commande."

    -
      :main_action: Ajouter
      :action:      le texte actuel au bout d’un fichier [même s’il n’existe pas]
      :mode: normal
      :code: ':write[!] >> <path/to/file>'
      :note: 'Pour être clair, sans « ! », la commande produit une erreur dans le cas où le fichier n’existe pas encore.'

    -
      :main_action: « Piper » le texte actuel
      :action:      vers un programme externe
      :mode: normal
      :code: ':write !<programme>'
    -
      :main_action: Aide
      :action:      sur la suppression en mode visuel
      :mode: normal
      :code: ':help v_d'
      :memo: '((v))isual ((d))elete'

    -
      :main_action: Réindenter
      :action:      '[x] ligne[s]'
      :code: '[x]KeyEgal KeyEgal'
      :note: '`x` est le nombre de lignes à réindenter'
      :memo: ((==)) Mêmes espaces
      :tags: ligne indentation

    -
      :main_action: Indenter
      :action:      la ligne courante
      :mode: insert
      :code: CTRL KeyT
      :note: "Bien noter que c’est en mode [INSERT].\nLa valeur de l’indentation dépendera de la valeur de l’option `shilfwidth`."
      :important: true

    -
      :main_action: Désindenter
      :action:      la ligne courante
      :mode: insert
      :code: CTRL KeyD
      :note: "Bien noter que c’est en mode [INSERT].\nLa valeur de l’indentation dépendera de la valeur de l’option `shilfwidth`."
      :important: true

    -
      :main_action: Indenter
      :action:      la [ou les] ligne[s] courante[s]
      :mode: normal
      :code: '[x] MAJ KeySupInf KeySupInf'
      :tags: ligne indentation

    -
      :main_action: Indenter
      :action:      un rang de lignes
      :mode: command
      :code: ':<rang> MAJ KeySupInf'
      :exemples:
        - '`:4, 6 MAJ KeySupInf` => indente les lignes 4 à 6 (les pousse vers la droite).'

    -
      :main_action: Désindenter
      :action:      un rang de lignes
      :mode: command
      :code: ':<rang> KeySupInf'
      :exemples:
        - '`:4, 6 KeySupInf` => désindente les lignes 4 à 6 (les pousse vers la gauche).'

    -
      :main_action: Désindenter
      :action:      la [ou les] ligne[s] courante[s]
      :mode: normal
      :code: '[x] KeySupInf KeySupInf'
      :tags: ligne indentation

    -
      :main_action: Désindenter
      :action:      plusieurs lignes successives
      :mode: insert
      :code: '0 CTRL KeyD'
      :note: 'Noter plusieurs choses : d’abord, on est en mode [INSERT] et donc le `0` sera écrit à l’écran. Noter ensuite que cette désindentation n’est pas définitive. L’utilisation de KeyEgalKeyEgal la supprimera.'

    -
      :main_action: Désindenter
      :action:      seulement une ligne et revenir à la même colonne
      :mode: insert
      :code: '^ CTRL KeyD'
      :note: 'Mêmes remarque que pour la commande précédente.'

    -
      :main_action: Définir
      :action: "la largeur max des lignes à entrer"
      :mode: normal
      :code: ":set textwidth=<nombre colonnes>"

    -
      :main_action: Définir
      :action: "la marge droite pour enroulement du texte"
      :mode: normal
      :code: ":set wrapmargin=<nombre colonnes>"

    -
      :main_action: Reformater
      :action:      paragraphe après modification (ajout/suppression)
      :mode: normal
      :code: "Sélectionner le texte puis `KeyGKeyQ`"
      :important: true
      :note: "Dépend de la définition de `textwidth` et/ou `wrapmargin` ci-dessus."

    -
      :main_action: Reformater
      :action:      des lignes en changeant la largeur de texte
      :mode: normal
      :code: ":set textwidth=<nombre colonnes>\nSélectionner le texte\nKeyGKeyQ"
      :important: true

    -
      :main_action: Reformater
      :action:      des lignes en indiquant leur nombre
      :mode: normal
      :code: KeyG KeyQ <nombre> j

    -
      :main_action: Reformater
      :action:      le paragraphe courant
      :mode: normal
      :code: KeyG KeyQ KeyI KeyP
      :memo: "((i))nner ((p))aragraph"
      :important: true

    -
      :main_action: Reformater
      :action:      la ligne courante
      :mode: normal
      :code:
        - KeyG KeyQ KeyG KeyQ
        - KeyG KeyQ KeyG KeyPoint

    -
      :main_action: Reformater
      :action:      les lignes jusqu’au prochain paragraphe
      :mode: normal
      :code: "KeyG KeyQ }"

    -
      :main_action: Reformater
      :action:      les lignes de commentaires
      :mode: visual
      :code: "Sélectionner les lignes, KeyG KeyQ"

    -
      :main_action: Reformater
      :action:      en utilisant un programme « externe »
      :mode: normal
      :code: ":set formatprg=<programme>"
      :exemples:
        - ":set formatprg=fmt"

    -
      :main_action: Aligner
      :action: des lignes au centre (aka centrer)
      :mode: normal
      :code: "Sélectionner les lignes\n:<from>,<to> center <width>"

    -
      :main_action: Aligner
      :action: des lignes à droite
      :mode: normal
      :code: "Sélectionner les lignes\n:<from>,<to> right <width>"

    -
      :main_action: Aligner
      :action: des lignes à gauche
      :mode: normal
      :code: "Sélectionner les lignes\n:<from>,<to> left <width>"

    -
      :main_action: "Jouer commande"
      :action: "en mode INSERT"
      :mode: insert
      :code: "CTRL KeyO <command>"
      :memo: "((o))ut"

    -
      :main_action: Afficher
      :action: "tous les caractères spéciaux"
      :mode: normal
      :code: ":digraphs"
      :tags: caractères_spéciaux

    -
      :main_action: Imprimer
      :action: "les lignes choisies"
      :mode: command
      :code: ":[from],[to]print"
      :exemples:
        - "`:5print` => imprimer la ligne 5"
        - "`:1,5print` => imprimer de la ligne 1 à la ligne 5"
        - "`:5,$print => imprimer de la ligne 5 à la fin du texte`"

    -
      :main_action: Imprimer
      :action: tout le fichier
      :mode: command
      :code: ':%print'

    -
      :main_action: Imprimer
      :action: la ligne courante
      :mode: command
      :code: ":.print"

    -
      :main_action: Imprimer
      :action: une ligne suivante par son contenu
      :mode: command
      :code: ":/<pattern>/print"
      :exemples:
        - "`:/arbre/print` => imprime la première ligne suivante contenant 'arbre'"

    -
      :main_action: Imprimer
      :action: la première ligne précédente contenant un texte
      :mode: command
      :code: ":?<pattern>?print"
      :exemples:
        - "`:?aigre?print` => imprime la première ligne précédente contenant 'aigre'"
        - "`:?bienKeyPointKeyDollar? print` => imprime la première ligne précédente se terminant par 'bien.'"

    -
      :main_action: Imprimer
      :action: "depuis et/ou jusqu'à une marque"
      :mode: command
      :code: ":'<a-z>, `<a-z> print"

    -
      :main_action: Imprimer
      :action:      le texte en visual mode
      :mode: visual
      :code: "Passer en mode visuel, sélectionner puis taper `:print` pour imprimer la sélection."

    -
      :main_action: Sortir en console
      :action:      le nombre de lignes du fichier
      :mode: command
      :code: ':='

# ---------------------------------------------------------------------
#
#   @@@ AUTOCOMPLÉTION
#
# ---------------------------------------------------------------------

  AUTOCOMPLÉTION:

    -
      :main_action: Afficher/ne plus afficher
      :action:      les fichiers possibles sur la barre de statut
      :mode: command
      :code: ':set [no]wildmenu'
      :note: 'Cette option agit lorsque l’on cherche un path par autocomplétion et qu’il y a plusieurs <em>candidats</em> pour répondre au wildcard.'
      :exemples:
        - 'Si l’on fait `:e ./au TAB` et qu’il y a plusieurs fichiers commençant par « au » dans le dossier, le nom de tous ces fichiers sera affiché dans la barre de statut et l’on pourra choisir le fichier voulu à l’aide de la touche TAB.'

    -
      :main_action: Régler l’autocomplétion fichier
      :action:      sur le plus long fichier
      :mode: command
      :code:
        -':set wildmode=longest (1)'
        -':set wildmode=longest:full'
      :note:
        - 'Remplit avec le plus long fichier plus s’arrête'
        - 'Remplit avec le plus long fichier pour poursuit si on continue de tabuler.'
        - 'Pour le moment, dans le Terminal, ça ne fait rien…'

    -
      :main_action: Régler l’affichage de
      :action:      la liste des fichiers possibles quand la touche d’autocomplétion fichier est jouée
      :mode: command
      :code: ':set wildmode=list'
      :note: 'Il semble que ça ne fonctionne pas comme décrit dans le fichier VIM, car ce mode n’a pas besoin de `list:full` pour procéder à l’autocomplétion après avoir affiché la liste.'

    -
      :main_action: Alterner les modes
      action:       d’autocomplétion de fichier
      :mode: command
      :code: ':set wildmode=<mode 1>,<mode 2>, etc.'
      :values:
        '<mode X>':
          - '`full`'
          - '`longest` => le plus long nom de fichier'
          - '`list` => par liste'


    -
      :main_action: Activer
      :action:      l’autocomplétion
      :code: "Démarrer Vim avec `$> vim -N`"
      :important: true

    -
      :main_action: Spécifier
      :action:      un ou plusieurs dictionnaires d’autocomplétion
      :code: ":set dictionary=file1,file2..."

    -
      :main_action: Spécifier
      :action:      un ou plusieurs fichiers thésaurus
      :code: ":set thesaurus=file1,file2,..."

    -
      :main_action: Restreindre
      :action:      'à une liste d’éléments (dictionnaire, tags, etc.)'
      :mode: insert
      :code: "CTRL KeyX, choisir l'option avec CTRL <touche>"
      :note: "l'option peut être CTRL KeyD : définition de macro, CTRL KeyF : nom de fichier, CTRL KeyK : dictionnaire, CTRL KeyT : thésaurus, CTRL KeyI : fichiers courants et #includes (en C), CTRL KeyL : lignes complètes, CTRL KeyO : “omni” complétion (omnifun)"
    -
      :main_action: Afficher
      :action:      les mots suggérés
      :mode: normal
      :code: CTRL KeyP

    -
      :main_action: Suggérer
      :action:      un mot du thésaurus
      :mode: insert
      :code: CTRL KeyP, CTRL KeyT
      :memo: "((T))hesaurus"

    -
      :main_action: Suggérer
      :action: "un mot d'un dictionnaire"
      :mode: insert
      :code: CTRL KeyP, CTRL KeyK
      :memo: "Di((K))tionnaire"

    -
      :main_action: Suggérer
      :action: "un mot se trouvant dans les fichiers dans le dossier courant"
      :mode: insert
      :code: CTRL KeyP, CTRL KeyF
      :memo: "((F))ile"
      :note: "Utiliser `CTRL KeyN` pour passer au fichier suivant"

    -
      :main_action: Choisir
      :action: "le mot précédent dans la liste proposée"
      :mode: insert
      :code: "CTRL KeyP (x fois)"
      :memo: "((P))revious, ((p))récédent"
      :note: "Chaque pression de la combinaison passe au mot suivant"

    -
      :main_action: Choisir
      :action: "le mot suivant dans la liste proposée"
      :mode: insert
      :code: "CTRL KeyN (x fois)"
      :memo: "((N))ext, suivant"
      :note: "On doit avoir afficher la liste des mots avec `CTRL KeyP`"


# ---------------------------------------------------------------------
#
#  @@@ TEXTE EXTRAS
#
# ---------------------------------------------------------------------

  TEXTE EXTRAS:

    -
      :main_action: Classer
      :action:      les lignes sélectionnées
      :mode: visual
      :code: "1. Sélectionner les lignes\n2. `!sort`"

    -
      :main_action: Piper (pailleper) les lignes courante
      :action:      en les passant par une commande
      :mode: visual
      :code: ':!<commande>'
      :exemples:
        - '`:!sort` => classe les lignes sélectionnées'

    -
      :main_action: "Surligner"
      :action: "du texte"
      :mode: normal
      :code: ":match <type> /<texte>/"
      :memo: "p.e. <code>:match Error /TOOD/"

    -
      :main_action: "Surligner"
      :action: "jusqu’à trois types/trois recherches en même temps"
      :mode: normal
      :code: ":match ..., :2match ..., :3match ..."

    -
      :main_action: Afficher
      :action: "tous les types de surlignages"
      :mode: normal
      :code: ':highlight'

    -
      :main_action: Supprimer
      :action: "tous les surlignages"
      :mode: normal
      :code: ":match none"

# ---------------------------------------------------------------------
#
#   @@@ RECHERCHER ET REMPLACER (mark "s")
#
# ---------------------------------------------------------------------

  RECHERCHE ET REMPLACEMENT:

    -
      :main_action: Régler
      :action: "recherche incrémentale"
      :mode: normal
      :code: ":set [no]incsearch"
      :memo: "((inc))remental search"

    -
      :main_action: Régler
      :action: "la recherche en mode [non] sensitif"
      :mode: normal
      :code: ":set [no]ignorecase"

    -
      :main_action: Régler
      :action: "la recherche pour rechercher sans sensitivité si le mot est tapé en minuscule."
      :mode: normal
      :code: ":set ignorecase \" ne tient pas compte de la case\n:set smartcase \"la case du mot entré comme rechercher influence la recherche"
      :exemples:
        - "'mot' recherchera 'mot', 'MOT', 'Mot', 'mOt'"
        - "'Mot' recherchera 'Mot'"
        - "'MOT' recherchera MOT"

    -
      :main_action: Régler
      :action: "la fin de la recherche à la fin du fichier [ou non]"
      :mode: normal
      :code: ":set [no]wrapscan \" sans 'no', recherche au début après la fin"

    -
      :main_action: Interrompre
      :action: 'une recherche'
      :mode: normal
      :code: CTRL KeyC

    -
      :main_action: Atteindre
      :action: 'la première occurrence du mot sous le curseur en avant'
      :mode: normal
      :code: "KeyEtoile (MAJ KeyDollar)"

    -
      :main_action: Atteindre
      :action: 'la première occurrence du mot sous le curseur en arrière'
      :mode: normal
      :code:
        - 'KeyLivre (MAJ `)'
        - 'KeyDiese (MAJ KeyArobase)'

    -
      :main_action: Atteindre
      :action: "la <xième> ligne [après ou avant] un mot"
      :mode: normal
      :code: "/<search>/[+|-]<x>"
      :note: "Recherche en arrière : `?<search>?[+|-]<x>`"
      :exemples:
        - "`/arobase/3` => Se place 3 lignes après le mot 'arobase'"
        - "`/arobase/-2` => Se place 2 lignes avant le mot 'arobase'"

    -
      :main_action: Répéter
      :action: "la recherche précédente"
      :mode: normal
      :code: '/'
      :note: "`?` en arrière"

    -
      :main_action: Répéter
      :action: "la recherche précédente en supprimant l'offset"
      :mode: normal
      :code: '//'
      :note: "`??` en arrière"

    -
      :main_action: Répéter
      :action: "la recherche précédente avec un autre offset"
      :mode: normal
      :code: '//[+|-]<x>'
      :note: "`??[+|-]<x>` en arrière"

    -
      :main_action: Placer le curseur
      :action: "<x> caractères [avant ou après] la recherche"
      :mode: normal
      :code:
        - "/<search>/b[+|-]<x>"
        - "/<search>/s[+|-]<x>"
      :note: "Recherche en arrière : `?<search>?b[+|-]<x>`"
      :exemples:
        - "`/marion/b5` => Se place 5 caractères après le mot 'Marion'"
        - "`/marion/b-6` => Se place 6 caractères avant le mot 'Marion'"
        - "`?marion?b-6` => Se place 6 caractères avant le mot 'Marion' trouvé en recherche arrière"


    -
      :main_action: Placer le curseur
      :action: "au bout de l'expression recherchée"
      :mode: normal
      :code: "/<search>/e"

    -
      :main_action: Placer le curseur
      :action: "<x> caractères [avant ou après] le bout de l'expression recherchée"
      :mode: normal
      :code: "/<search>/e[+|-]<x>"
      :exemples:
        - "`/Marion/e4` => Place le curseur 4 caractères après le 'n' de Marion"
        - "`/Marion/e-2` => Place le curseur sur le 'i' de 'Marion'"
      :note: "Utiliser le code `//<x>` pour recommencer la recherche avec un autre offset."

    -
      :main_action: Rechercher
      :action: "une expression régulière dans des fichiers quelconques"
      :mode: normal
      :code: ":vimgrep /<reg exp>/ <where>"
      :exemples:
        - "`:vimgrep /phil(ippe)?/ ~/Programmation` => recherche toutes les occurrences de 'phil' ou 'philippe' dans le dossier Programmation"
        - "`:vimgrep /phil(ippe)?/ ./**/*.txt` => toutes les occurrences de 'phil' ou 'philippe' dans les fichiers .txt du dossier courant et ses sous-dossiers."
      :important: true

    -
      :main_action: Afficher
      :action: "dans une nouvelle fenêtre tous les résultats de `:vimgrep`"
      :code: ":cope[n]"
      :exemples:
        - "`:vimgrep /phil/ ./*.data`, :copen, KeyJ/KeyK, ENTER pour afficher le fichier."

    -
      :main_action: Afficher
      :action: "le résultat suivant de `:vimgrep`"
      :code: ":cn[ext]"
      :memo: "((next)) = suivant"

    -
      :main_action: Afficher
      :action: "le résultat précédent de `:vimgrep`"
      :code:
        - ':cp[revious]'
        - ':cN[ext] (MAJ KeyN)'
      :memo: "((previous)) = précédent"

    -
      :main_action: Afficher
      :action: "le premier résultat de `:vimgrep` dans le fichier suivant"
      :code: ":cnfile"
      :memo: "((n))ext"

    -
      :main_action: "Surligner/retirer"
      :action: "l'exergue les textes trouvés"
      :mode: normal
      :code: ':set [no]hlsearch'
      :memo: "((h))igh((l))ight search"

    -
      :main_action: Supprimer
      :action: "la mise en relief courante"
      :mode: normal
      :code: ":nohlsearch"

    -
      :main_action: Chercher
      :action: "en avant quelque chose"
      :mode: normal
      :code: "/<quelque chose> ENTER"
      :memo: Il faut escaper les signes `.*[]^%/\?~KeyDollar`

    -
      :main_action: Chercher
      :action: "en avant la première occurrence de la lettre, puis les suivantes"
      :mode: normal
      :code: "KeyF<lettre>, puis ; (KeyPoint_virgule) pour les suivantes, ou « , » (virgule) pour les précédentes."

    -
      :main_action: Chercher
      :action: "quelque chose en arrière"
      :mode: normal
      :code: "?<quelque chose> ENTER"

    -
      :main_action: Aller
      :action:      au(x) prochain(s) quelque chose (avant ou arrière)
      :mode: normal
      :code:
        - '[x]KeyN'
        - '[x]/ ENTER'
        - '[x]? ENTER'

    -
      :main_action: Aller
      :action:      au(x) prochain(s) quelque chose en sens inverse
      :mode: normal
      :code: MAJ KeyN

    -
      :main_action: "Inverser"
      :action: "la recherche"
      :mode: normal
      :code: "? si on est en avant, sinon /"

    -
      :main_action: Afficher
      :action: "l’historique des recherches en avant"
      :mode: normal
      :code: "KeyQ/\n/ARROW_UP /ARROW_DOWN"
      :memo: "Pour en sortir sans rien faire : CTRL KeyC ou \":KeyQ ENTER\""

    -
      :main_action: Afficher
      :action: "l’historique des recherches en arrière"
      :mode: normal
      :code: "KeyQ?\n?ARROW_UP ?ARROW_DOWN"
      :memo: "Pour en sortir sans rien faire : CTRL KeyC ou \":KeyQ ENTER\""

    -
      :main_action: Substituer
      :action:      du texte dans le fichier courant
      :code: \:[<range> ]s[ubstitute]/<get>/<set>[/<flags>]
      :values:
        '<flags>':
          - '`g` => toutes les occurrences dans la ligne courante'
          - '`p` => en écrivant ((p)rint) les lignes modifiées'
          - '`c` => demande confirmation pour chaque changement'
          - '`e` => pas de sortie d’erreur, même si aucune occurrence'
          - '`i` => substitution non sensible à la casse'
          - '`I` => substitution sensible à la casse, même si l’option dit le contraire'
          - '`l` => imprime la ligne en mode « liste » après la substitution'
          - '`n` => indique le nombre de substitution opérée mais sans rien faire.'
          - '`r` => si la pattern de recherche est vide, utiliser la précédente'
      :exemples:
        - '`:s/Phil/Marion/` => remplace une seule fois « Phil » par « Marion » dans la ligne courante.'
        - '`:s ,Phil,Marion,gp` => Remplace tous (drapeau « g ») les « Phil » par des « Marion » dans la ligne courante et écrit la dernière ligne modifiée en console (drapeau « p »).'
        - '`:% +Phil+Marion+g` => Remplace tous (flag « g ») les Phil par des Marion dans le fichier (rang « % »)'
      :note: 'On peut remplacer le « / » par n’importe quel autre caractère à part un nombre, une lettre, la balance arrière, les doubles guillemets ou la barre verticale. Voir les exemples.'
      :memo: ((s))each

    -
      :main_action: Substituer
      :action:      toutes les occurrences de la ligne courante
      :code: ':s/<get>/<set>/g'
      :memo: ((s))each, ((g))lobal

    -
      :main_action: Substituer
      :action:      dans tout le fichier
      :mode: command
      :code: ':% s/<get>/<set>/g'
      :memo: "((s))each, ((g))lobal, ((%)) signife «tout le texte»"

    -
      :main_action: Substituer
      :action:      toutes les occurrences dans plusieurs lignes consécutives
      :code: "Passer en mode visuel avec MAJ KeyV [VISUAL-LINE] Sélectionner les lignes [COMMAND] :s/.../.../g ENTER"

    -
      :main_action: Substituer
      :action:      toutes les occurrences dans plusieurs lignes consécutives
      :mode: command
      :code: ":<de ligne>,<à ligne> s/.../.../g"
      :note: "Pour la dernière ligne, on peut utiliser `KeyDollar`."

    -
      :main_action: Substituer
      :action:      avec une expression régulière
      :mode: command
      :code:
        - ':s,<reg exp>,<set>[,<flags>] (si l’option « magic » est active)'
        - ':sm[agic],<reg exp>,<set>[,<flags>] (si l’option « magic » n’est pas active)'

    -
      :main_action: Substituer
      :action:      sans expression régulière
      :mode: command
      :code:
        - ':s,<exp>,<set>[,<flags>] (si l’option « magic » n’est pas active)'
        - ':sno[magic],<exp>,<set>[,<flags>] (si l’option « magic » est active)'
      :exemples:
        - '`:snomagic,***,+++,g` => remplacera vraiment les « *** » par des « +++ »'

    -
      :main_action: Substituer
      :action:      à nouveau en modifier le rang ou les drapeaux
      :mode: command
      :code: ':<rang> & <drapeau>'
      :exemples:
        - 'On joue d’abord `s,Phil,Marion` qui remplace une fois Phil par Marion dans la ligne. Si on fait `:&gp`, ça remplace tous les Phil et ça montre la ligne modifiée.'
      :note: 'Il faut répéter les drapeaux s’il y en a dans la définition initiale'

    -
      :main_action: Substituer
      :action:      en remplaçant [ou non] par défaut toutes les occurrences de la ligne
      :mode: command
      :code: ':set [no]gdefault'
      :note: 'Attention, ça peut entrainer des conséquences fâcheuses sur certains scripts.'

    -
      :main_action: Remplacer
      :action:      le caractère au curseur par le caractère fourni
      :mode: normal
      :code: "KeyR <lettre>"

    -
      :main_action: Remplacer
      :action:      les caractères au curseur jusqu'à la sortie du mode
      :mode: normal
      :code:
        - "MAJ KeyR <texte> ESC (ou CTRL KeyC)"
        - "KeyG MAJ KeyR <texte> ESC"

    -
      :main_action: Remplacer
      :action: "les [x] caractères par le texte fourni"
      :mode: normal
      :code: "[x]s<texte>"
      :note: "Vim passe en mode INSERT après que la touche KeyS a été pressée."

    -
      :main_action: Remplacer
      :action:      le caractère courant par le texte fourni
      :mode: normal
      :code: "s<texte>"
      :note: "Mais contrairement à KeyR qui reste en mode [NORMAL], Vim reste en mode [INSERT] après que la touche KeyS a été pressée."

    -
      :main_action: Remplacer
      :action:      la ligne courante par le texte fourni
      :mode: normal
      :code: "MAJ KeyS<texte>"
      :note: "Vim passe en mode INSERT après que la touche KeyS a été pressée."

    -
      :main_action: Remplacer
      :action:      'le texte en mode [SELECT]'
      :mode: normal
      :code: 'KeyGKeyH, KeyFlecheG/KeyFlecheD pour sélectionner, <texte>'
# ---------------------------------------------------------------------
#
#   @@@ EXPRESSIONS RÉGULIÈRES
#
# ---------------------------------------------------------------------

  EXPRESSION RÉGULIÈRES:

    -
      :main_action: Spécifier
      :action: "le début d'un mot"
      :code: '\<'
      :exemples:
        - "`\\<pour\\>` recherche le mot 'pour' exactement, et exclus par exemple 'pourparler'"

    -
      :main_action: Spécifier
      :action: "la fin d'un mot"
      :code: '\>'

    -
      :main_action: Spécifier
      :action: 'de rechercher zéro ou plusieurs occurrences'
      :code: '\*'

    -
      :main_action: Spécifier
      :action: 'de rechercher une ou plusieurs occurrences'
      :code: '\+'

    -
      :main_action: Spécifier
      :action: 'de rechercher une ou zéro occurrences'
      :code: '\='

    -
      :main_action: Rechercher
      :action: 'un caractère alphabétique'
      :code: '\a'

    -
      :main_action: Rechercher
      :action: 'un caractère non alphabétique'
      :code: '\A'

    -
      :main_action: Spécifier
      :action: 'de rechercher n’importe quel chiffre'
      :code: '\d'

    -
      :main_action: Rechercher
      :action: 'n’importe quelle lettre majuscule'
      :code:
        - '\u'
        - '[[:upper:]]'
      :memo: '((u))pper'
      :note: 'Plus rapide que de faire `[A-Z]`.'

    -
      :main_action: Rechercher
      :action: 'tout sauf des majuscules'
      :code: '\U'

    -
      :main_action: Rechercher
      :action: 'n’importe quelle lettre minuscule'
      :code:
        - '\l'
        - '[[:lower:]]'
      :memo: '((l))ower'
      :note: 'Plus rapide que `[a-z]`'

    -
      :main_action: Rechercher
      :action: 'tout sauf des minuscules'
      :code: '\L'

    -
      :main_action: Rechercher
      :action: 'n’importe quel caractère hexadécimal (0-F)'
      :code: '\x'

    -
      :main_action: Rechercher
      :action: 'n’importe quel caractère non hexadécimal (0-F)'
      :code: '\X'

    -
      :main_action: Spécifier
      :action: 'de rechercher un nombre précis de caractères'
      :code: '\{<nombre>}'
      :exemples:
        - '`a\{5}` => recherche exactement 5 "a"'

    -
      :main_action: Recherche
      :action: 'le mininum de caractères'
      :code: '\{-<de>, <à>}'
      :exemples:
        - '`a\{-3,5}` => recherche entre 3 et 5 "a" sur la ligne, mais renverra l’atom le plus court.'

    -
      :main_action: Grouper
      :action: 'des caractères'
      :code: '\(<caractères>\)'

    -
      :main_action: Faire références
      :action: 'à un groupe de caractères défini entre parenthèses'
      :code: '\<index parenthèses 1-start>'
      :exemples:
        - 'dans `a\([b-d]\)1\([0-5]\)`, "\1" faire référence à "[b-d]" et "\2" fait référence à "[0-5]".'

# ---------------------------------------------------------------------
#
#   @@@ PRESSE PAPIER | REGISTRE
#
# ---------------------------------------------------------------------

  PRESSE-PAPIER (REGISTRE):

    -
      :main_action: Enregistrer
      :action:      dans un registre de a à z
      :code: '"<lettre><quoi>'
      :memo: "p.e. : `\"KeyCKeyYKeyY`\n=> copier la ligne dans 'c'"

    -
      :main_action: Insérer
      :action:      le contenu d’un registre (en mode normal)
      :mode: normal
      :code: '"<lettre>KeyP'
      :memo: ((p))aste

    -
      :main_action: Insérer
      :action:      le contenu d’un registre [avant] (en mode command)
      :mode: command
      :code: ':<numéro ligne> put[!] <lettre registre>'
      :exemples:
        - '`:6 put e` => insert le contenu du registre « e » après la 6e ligne.'
        - '`:6 put! e` => insert le contenu du registre « e » AVANT la 6e ligne.'

    -
      :main_action: Insérer
      :action:      le contenu d’un registre en adaptant l’identation
      :mode: normal
      :code: '"<lettre> ALT MAJ KeyCrochetF KeyP'
      :memo: ((p))aste

    -
      :main_action: Insérer
      :action:      le contenu d’un registre (en mode insert)
      :mode: insert
      :code: 'CTRL KeyR <registre>'
      :memo: '((R))egistre'
      :exemples:
        - '`CTRL KeyR =` insert au curseur le registre "='
      :important: true

    -
      :main_action: Insérer
      :action:      le contenu d’un registre sans indenter (en mode insert)
      :mode: insert
      :code: CTRL KeyR KeyO <registre>
      :exemples:
        - '`CTRL KeyR KeyO a` -> insert le registre "a"'

    -
      :main_action: Insérer
      :action:      le contenu d’un registre en laissant Vim gérer l’identation.
      :mode: insert
      :code: CTRL KeyR KeyP <registre>
      :exemples:
        - '`CTRL KeyR KeyP r` -> insert le registre "r" en gérant l’identation correctement.'

    -
      :main_action: Insérer
      :action:      le contenu de la dernière suppession
      :mode: normal
      :code: '"1 KeyP'
      :note: 'Les autres suppressions se trouvent dans les registres de 2 à 9'

    -
      :main_action: Insérer
      :action:      le contenu de l’avant-dernière suppression
      :mode: normal
      :code: '"2 KeyP'
      :note: 'Les autres suppressions se trouvent dans les registres de 3 à 9'

    -
      :main_action: Ajouter
      :action:      du texte dans un registre
      :code: '"MAJ <lettre registre><quoi>'
      :exemples:
        - '`"A KeyYKeyY` => Ajoute la ligne courante au registre « a »'
        - '`"Z KeyYKeyW` => Ajoute le mot au registre « z »'

    -
      :main_action: Afficher
      :action:      le contenu de tous les registres
      :mode: normal
      :code: ':reg[isters]'

    -
      :main_action: Afficher
      :action:      le contenu de registres en particulier
      :mode: normal
      :code: ':reg[isters] <lettre><lettre> etc.'
      :exemples:
        - '`:registers az` => affiche le contenu des registres "a et "z'
        - '`:reg qsb` affiche le contenu des registres "q, "s et "b'

    -
      :main_action: Exécuter
      :action:      le contenu d’un registre [après une certaine ligne]
      :mode: command
      :code: ':[line]@<registre>'

    -
      :main_action: Référence
      :action:      au registre global
      :code: '" MAJ KeyPlus'

    -
      :main_action: Référence
      :action:      au registre « poubelle »
      :code: '"_'

# ---------------------------------------------------------------------
#
#   @@@ COMMANDES (mark c)
#
# ---------------------------------------------------------------------

  COMMANDES:

    -
      :main_action: Passer en revue
      :action:      toutes les commandes entrées en cours de session
      :mode: normal
      :code:
        - ': KeyFlecheH'
        - ': KeyFlecheB'

    -
      :main_action: Afficher
      :action:      tout l’historique des commandes entrées au cours de la session
      :mode: normal
      :code:
        - 'q:'
        - 'CTRL KeyF'
      :note: 'Définir l’option `cmdwinheight` (`cwh`) pour régler la hauteur de la fenêtre affichant la liste.'

    -
      :main_action: Quitter
      :action:      tout [sans sauver]
      :mode: normal
      :code: ':qall[!]'
      :memo: "quit ((all))"

    -
      :main_action: Quitter
      :action:      en enregistrant tout
      :mode: normal
      :code: MAJ KeyZKeyZ
      :memo: ((zzz)) (dodo)
      :important: true

    -
      :main_action: Exécuter
      :action:      une commande externe
      :code: \:!<commande>

    -
      :main_action: Répéter
      :action:      la dernière commande externe exécutée
      :code: ':!!'

    -
      :main_action: Annuler
      :action:      la dernière commande
      :mode: normal
      :code: KeyU
      :memo: ((u))ndo

    -
      :main_action: Annuler
      :mode: command
      :code: ':undo'

    -
      :main_action: Annuler
      :action:      toutes les modifications faites sur la ligne courante
      :mode: normal
      :code: MAJ KeyU
      :memo: ((U))ndo

    -
      :main_action: Annuler
      :action:      les modifications annulées par U sur la ligne courante
      :mode: normal
      :code: MAJ KeyU

    -
      :main_action: Annuler
      :action:      une annulation
      :mode: normal
      :code: CTRL KeyR
      :memo: ((r))edo

    -
      :main_action: Désactiver
      :action:      tous les plugins en démarrant Vim
      :code: "$> vim -u NONE"

    -
      :main_action: Passer en mode
      :action:      insertion
      :mode: command
      :code: ':startinsert'
      :note: 'Correspond à la touche KeyI en mode normal.'

    -
      :main_action: Demander
      :action:      confirmation avant l’exécution d’une commande
      :mode: command
      :code: :confirm <commande>
      :exemples:
        - '`:confirm :quit` => si le fichier a été modifié, demande confirmation avant de quitter.'

    -
      :main_action: Définir
      :action:      une variable
      :mode: command
      :code: ':let <nom variable> = <valeur variable>'
      :exemples:
        - '`:let mon_nom = "Phil"`'
        - '`:let mon_age = 53`'
      :values:
        '<nom variable>':
          - 'Tout en capitales, peut être sauvée dans le viminfo si l’option contient « ! »'
          - 'Si commence par capitale (tout doit être en minuscules ensuite), sera sauvée par la commande `:mksession`.'
          - 'Tout en minuscule : perdure juste le temps de la session'
          - '`$<name>` => variable d’environnement'
          - '`@<register>` => text register'
          - '`&<option>` => le nom d’une option'
          - '`b:<variable name>` => variable locale au buffer'
          - '`w:<variable name>` => variable locale à la fenêtre'
          - '`g:<variable name>` => variable globale'
          - '`v:<variable name>` => variable interne à Vim (`v:count`, `v:count1`, `v:errmsg`, `v:warningmsg`, `v:statusmsg`, `v:shell_error`, `v:this_session`)'

    -
      :main_action: Supprimer
      :action:      la définition d’une variable
      :mode: command
      :code: ':unlet <nom variable>'

    -
      :main_action: '[Dé]Bloquer'
      :action:      une variable
      :mode: command
      :code:
        - ':[un]lockvar <nom variable>'
        - ':lockv <nom variable>'
        - ':unlo <nom variable>'

    -
      :main_action: Écrire
      :action:      un message en console sur une nouvelle ligne
      :mode: command
      :code: ':echo <texte>'

    -
      :main_action: Écrire
      :action:      un message en console au bout du texte (sans nouvelle ligne)
      :mode: command
      :code: ':echon <texte>'
      :exemples:
        - '`echo "aa" | echo "ab"` => produit `aaab` sur une même ligne en console'
      :note: 'Dans l’exemple, la barre verticale permet de jouer plusieurs commandes.'

    -
      :main_action: Écrire
      :action:      un message en couleur en console
      :mode: command
      :code: ':echohl <type couleur> | echo "mon message coloré" | echohl None'
      :note: 'Pour voir les types de couleur, taper `:hi[ghlight]` en console. `hl` comme `highlight`. '
      :exemples:
        - '`:echohl ErrorMsg | echo "Ceci est une erreur en rouge." | echohl None` => Écrire "Ceci est une erreur en rouge." en rouge dans la console.'
      :values:
        '<type couleur>':
          - 'ErrorMsg'

    -
      :main_action: Écrire
      :action:      un message d’erreur
      :mode: command
      :code: ':echoe[rr]'
      :memo: 'Comme ((echo)) ((err))eur'
      :note: 'Si employé dans un script ou une fonctoin, ce code ajoute la ligne dans l’historique des erreurs et ajoute un numéro de ligne.'

    -
      :main_action: Écrire
      :action:      un message notice
      :mode: command
      :code: ':echom[sg]'
      :memo: '((echo)) ((m))e((s))sa((g))e'
      :note: 'Si employé dans un script ou une fonction, ajoute aux messages de suivi qu’on peut relire avec `:messages`.'

# ---------------------------------------------------------------------
#
#   @@@ COMMANDES PERSONNELLES
#
# ---------------------------------------------------------------------

  COMMANDES PERSONNELLES:

    -
      :main_action: Créer
      :action:      une commande
      :mode: command
      :code: ':command <NomCommande> <code à exécuter>'
      :note: 'Les commandes personnelles doivent commencer par une capitale.'
      :exemples:
        - '`:command SuppEntete :1delete` => quand on tape `:SuppEntete`, cela supprime la première ligne'
        - '`:command <SID>Delete :1,delete` => Définit la commande `Delete`, mais en lui collant un préfixe qui supprimera toute collision possible avec des fonctions ou commandes existantes.'

    -
      :main_action: Lister
      :action:      les commandes personnalisées
      :mode: command
      :code: ':command'

    -
      :main_action: Supprimer
      :action:      une commande personnalisée
      :mode: command
      :code: ':delcommand <NomCommande>'

    -
      :main_action: Supprimer
      :action:      toutes les commandes personnalisées
      :mode: command
      :code: ':comclear'

    -
      :main_action: Définir
      :action:      les arguments d’une commande
      :mode: command
      :code: ':command -nargs=<valeur> <NomCommande> <code utilisant les arguments>'
      :values:
        '<valeur>':
          - '`0` => aucun argument'
          - '`1` => un argument, 2, etc.'
          - '`*` => nombre indéterminé d’arguments'
          - '`?` => Zéro ou un argument'
          - '`+` => Un ou plus arguments'
      :exemples:
        - '```" Soit la commande définie par :\n\n:command -nargs=+ Dire :echo "<args>"\n\n" Si l’on joue :\n\n:Dire Bonjour tout le monde !\n\n" Cela écrira en console :\n\nBonjour tout le monde !```'

    -
      :main_action: Utiliser
      :action:      un rang de ligne comme argument
      :mode: command
      :code: ':command <-range> <Commande> <code à exécuter>'
      :note: 'Lorsqu’un rang est fourni, `<line1>` et `<line2>` fournissent les valeurs de ce rang.'
      :values:
        '<-range>':
          - '`-range` => un rang est attendu. Défaut : la ligne courante'
          - '`-range=%` => rang attendu, par défaut, le fichier entier'
          - '`-range=<count>` => juste un numéro de ligne dont le numéro est `<count>`'

    -
      :main_action: Passer des arguments
      :action:      à une fonction comme une liste
      :mode: command
      :code: ':command -narg=* MaCommande :call UneFonction(<f-args>)'
      :exemples:
        - '```" Quand on fera :\n\nMaCommande un deux trois\n\n" Ça correspondra à un appel :\n\nUneFonction("un", "deux", "trois")```'
      :tags: commandes
# ---------------------------------------------------------------------
#
#   @@@ LIGNE DE COMMANDE ET LANGAGE DE SCRIPT
#
# ---------------------------------------------------------------------

  LIGNE DE COMMANDE ET LANGAGE DE SCRIPT:

    -
      :main_action: Statement IF
      :mode: command
      :code: ':if {condition} | <statement> | elseif | <statement> | else | <statement> | endif'
      :note: 'Bien sûr, les « | » peuvent être remplacés par des retours à la ligne avec ajoute de « : » en début de ligne : ```:if <condition>\n: <statement>\n: <statement>\n:endif```'
      :exemples:
        - '`if 4 > 5 | echo "C’est vrai" | else | echo "C’est faux" | endif`'

    -
      :main_action: Exécuter
      :action:      une boucle WHILE
      :mode: command
      :code:
        - ':while <condition> | <statement> | endwhile'
        - '```:while <condition>\n: <statement>\n: <statement>\n:endwhile```'
      :note: 'On peut passer directement à la valeur suivante avec `continue` ou sortir de la boucle avec `break`.'

    -
      :main_action: Exécuter
      :action:      une boucle FOR
      :mode: command
      :code:
        - ':for <condition> | <statement> | endfor'
        - '```:for <condition>\n:  <statement>\n:  <statement>\n:endfor```'
      :exemples:
        - '```:let liste=["a", "b", "c"]\n:for lettre in liste\n: echo lettre\n:endfor```'

    -
      :main_action: Évaluer
      :action:      une commande
      :mode: command
      :code: ':exe[cute] <commande>'
      :exemples:
        - '```:let ma_commande = "echo \"Salue le monde !\""\n:execute ma_commande``` => écrit "Salue le monde !" en console.'

    -
      :main_action: Placer le code
      :action:      dans un bloc d’erreur
      :mode: command
      :code:
        - ':try | <statement> | catch <exp régulière> | <statement> | finaly | <statement> | endtry'
        - '```:try\n:  <une opération>\n:catch /<exp régulière de test d’erreur>/\n:  <statement en cas d’erreur>\n:finally\n: <à faire dans tous les cas>\n:endtry``` '
      :exemples:
        - '```:try\n: unemauvaisecommande\n:catch /^E492/\n: echo "Cette commande est inconue."\n:endtry```'
      :note: 'On lève une erreur à l’aide de `:throw "<erreur>"` dans le statement. On utile `:finish` pour finir le code du bloc try.'

# ---------------------------------------------------------------------
#
#   @@@ INTERFACE
#
# ---------------------------------------------------------------------

  INTERFACE:

    -
      :main_action: Afficher/masquer
      :action:      les numéros de ligne
      :code: ":set [no]number"

    -
      :main_action: Appliquer
      :action:      un thème particulier pour cette session
      :mode: normal
      :code: ":colo[rscheme] <nom du thème sans .vim>"
      :exemples:
        - "Le thème doit se trouver dans `./.vim/colors/`"
        - ":colorscheme Tomorrow"

    -
      :main_action: Définir
      :action:      un thème particulier dans `.vimrc`
      :code: "colo[rscheme] <nom du thème>\nsyntax on"

    -
      :main_action: Choisir
      :action:      le type de fond (clair ou sombre)
      :mode: command
      :code: :set background=<light|dark>
      :note: 'Il faut bien sûr que le thème courant possède ces deux versions. Essayer par exemple avec `elrodeo`'

    -
      :main_action: Définir
      :action:      l’apparence du texte
      :mode: normal
      :code:
        - ':hi[ghlight] <groupe> cterm=<aspect> ctermfg=<couleur police> ctermbg=<couleur fond>'
        - ':hi[ghlight] <groupe> start=<ESC>X stop=<ESC>Y'
      :exemples:
        - '`:highlight Comment cterm=underline ctermfg=red ctermbg=blue` => Tous les commentaires seront soulignés, en rouge sur fond bleu (horribles, quoi…)'
        - '`:hi Keyword ctermfg=4`'
      :values:
        '<groupe>':
          - '`Keyword` : les mots-clés du langage'
          - '`Comment` : les commentaires'
          - 'etc.'
      :note: Pour une version plus avancée de l’utilisation, voir l’aide.

    -
      :main_action: Définir
      :action:      la hauteur de la fenêtre affichant la liste des commandes
      :mode: normal
      :code:
        - ':set cmdwinheight=<nombre de lignes>'
        - ':set cwh=<nombre lignes>'
      :memo: '((cmd))=Command, ((win))=Window, ((height))=hauteur'

    -
      :main_action: '[Dés]Activer'
      :action:      le folding
      :mode: normal
      :code:
        - ':set [no]foldenable'
        - 'KeyZ KeyN (off), KeyZ MAJ KeyN (on)'
        - 'KeyZ KeyI (toggle)'

    -
      :main_action: Définir manuellement le folding
      :action:      du code courant
      :mode: normal
      :code: KeyZ KeyF
      :memo: '((f))old'
      :tags: folding

    -
      :main_action: Définir le folding
      :action:      à l’aide d’un string d’entrée et de sortie
      :mode: command
      :code:
        - ':set foldmethod=marker; :set foldmarker=<entrée>,<sortie>'
        - ':set fdm=marker; :set fdr=<in>,<out>'
      :exemples:
        - '`:set foldmethod=marker; :set foldmarker=<,>`'
      :note: "Ensuite, on peut ajouter un level après l’entrée et la sortie. Par exemple :\n`<1\nMon texte de niveau 1\n<2\nLe texte de niveau 2.Autre ligne dans le niveau 2\n>2\n>1`"
      :tags: folding

    -
      :main_action: Définir
      :action:      la marque quand le folding est replié
      :mode: command
      :code: ':set foldtext=v:<valeur>'
      :values:
        'valeur':
          - '`` (rien) : `+--- <x> lines folded`'
          - '`foldstart` : le numéro de la première ligne'
          - '`foldend` : le numéro de la dernière ligne'
          - '`foldlevel` : niveau de folding'
          - '`folddashes` : un caractère défini (mais je ne sais pas comment)'
      :tags: folding

    -
      :main_action: Définir
      :action:      la largeur de la colonne de gauche
      :mode: command
      :code:
        - ':set foldcolumn=<nombre de 0 (défaut) à 12>'
        - ':fdc=<0-12>'
      :tags: folding

    -
      :main_action: Folder
      :action:      les x lignes suivantes par un nombre ou un rang
      :mode: command
      :code:
        - '<nombre> KeyZ MAJ KeyF'
        - ':<first line>, <last line> fold'
      :tags: folding

    -
      :main_action: Supprimer
      :action:      le folding sous le curseur.
      :mode: normal
      :code: KeyZ KeyD
      :memo: '((d))elete'
      :note: 'Il suffit de se trouver dans le folding et d’exécuter cette combinaison.'
      :tags: folding

    -
      :main_action: Supprimer
      :action:      récursivement tous les folding sous le curseur.
      :mode: normal
      :code: KeyZ MAJ KeyD
      :tags: folding

    -
      :main_action: Toggler (ouvrir/fermer)
      :action:      le folding sous le curseur
      :mode: normal
      :code: KeyZ KeyA

    -
      :main_action: Toggler (ouvrir/fermer)
      :action:      tous les niveaux de folding sous le curseur
      :mode: normal
      :code: KeyZ MAJ KeyA

    -
      :main_action: Replier (collapse)
      :action:      le code courant
      :mode: normal
      :code:
        - KeyZ KeyC
        - ':<rang> foldc[lose]'
      :memo: '((c))lose'
      :tags: folding

    -
      :main_action: Déplier (open)
      :action:      le code courant
      :mode: normal
      :code:
        - KeyZ KeyO
        - ':<range> foldo[pen]'
      :memo: '((o))pen'
      :tags: folding

    -
      :main_action: Se déplacer
      :action:      au début du folding courant
      :mode: normal
      :code: ALT MAJ KeyCrochetO KeyZ
      :tags: folding

    -
      :main_action: Se déplacer
      :action:      à la fin du folding courant
      :mode: normal
      :code: ALT MAJ keyCrochetF KeyZ
      :tags: folding

    -
      :main_action: Se déplacer
      :action:      au folding suivant
      :mode: normal
      :code: keyZ KeyJ
      :tags: folding

    -
      :main_action: Se déplacer
      :action:      au folding précédente
      :mode: normal
      :code: KeyZ KeyK
      :tags: folding

    -
      :main_action: Exécuter une action
      :action:      sur tous les foldings ouverts
      :mode: command
      :code: ':% folddoopen <command>'
      :exemples:
        - '`:% folddoopen s/Marion/Bébé/g` -> Change tous les "Marion" par des "Bébé" dans les foldings ouverts'
      :note: 'On peut faire la même chose avec les foldings fermés à l’aide de `folddoclosed` (mais bon, c’est un peu risqué quand même).'
      :tags: folding

    -
      :main_action: Définir
      :action:      ce qui peut ouvrir les foldings
      :mode: normal
      :code:
        - ':set foldo[pen]=<liste valeurs>'
        - ':set fdo=<valeurs>'
      :note: 'Consulter l’aide pour voir toutes les valeurs possibles.'
      :tags: folding

    -
      :main_action: Définir
      :action:      ce qui crée les foldings
      :mode: normal
      :code:
        - ':set foldmethod=<valeur>'
        - ':set fdm=<valeur>'
      :values:
        '<valeur>':
          - '`diff` en fonction de l’opération checkant les différences'
          - '`expr` : folding créés par une l’expression définie par `foldexpr` (`fde`)'
          - '`indent` : folding créés par l’indentation'
          - '`manual` : folding créés manuellement'
          - '`marker` : folding créés par des markers'
          - '`syntax` : folding créés par la syntaxe (n’importe quel élément de syntaxe qui possède l’option `fold`)'

    -
      :main_action: Définir
      :action:      la ligne d’état
      :mode: command
      :code: ':set statusline'
      :note: "Voir l’aide pour toutes les possibilités : `:help 'statusline'`."

# ---------------------------------------------------------------------
#
#   @@@ OPTIONS
#
# ---------------------------------------------------------------------

  OPTIONS:

    -
      :main_action: Définir
      :action:      de lire le .vimrc dans le dossier courant
      :mode: command
      :code: ':set exrc'
      :notes:
        - 'L’option est désactivée par défaut, ce qui fait que c’est toujours le .vimrc placé à la racine du $HOME qui est lu.'
        - 'Jouer la commande `:set secure` avant pour empêcher l’exécution des `autocommand`, `write` et `shell` quand on met cette option pour un dossier inconnue.'

    -
      :main_action: Définir
      :action:      la valeur d'une option non booléenne
      :mode: command
      :code:
        - ':set <option>=<valeur>'
        - ':set <option>:<valeur>'

    -
      :main_action: Régler
      :action:      plusieurs valeurs d’options à la fois
      :mode: command
      :code: ':set <option>=<valeur> <autre option>=<valeur> <option booléenne> etc.'

    -
      :main_action: Régler
      :action:      les options pour un fichier
      :mode: file
      :code: '/* vim: set <option>=<valeur> : <opt>=<val> : <opt bool> : */'
      :note: 'Cette ligne doit IMPÉRATIVEMENT être placée sur la PREMIÈRE LIGNE du fichier. C’est ce qu’on appelle la « modeline » (ligne de mode)'
      :important: true

    -
      :main_action: Définir
      :action:      le nombre de ligne pour la modeline
      :mode: command
      :code: ':set modelines=<nombre de lignes au début du fichier'

    -
      :main_action: Activer/désactiver
      :action:      le mode Modeline
      :mode: command
      :code: ':set [no]modeline'
      :note: 'En mode « modeline », Vim lit les x premières lignes d’un fichier ouvert pour régler les options'

    -
      :main_action: '[Dés]activer'
      :action:      l’enroulement des lignes à l’affichage
      :mode: normal
      :code: ":set [no]wrap"
      :note: "Avec `nowrap`, les lignes ne seront pas enroulées et s'étendront sur une seule ligne d'affichage."

    -
      :main_action: "[Dés]activer"
      :action:      la correction autographique
      :mode: normal
      :code: ":set [no]spell"

    -
      :main_action: Activer/désactiver
      :action:      l’option de la relecture automatique (après modification du fichier ailleurs)
      :code: ":set [no]autoread"

    -
      :main_action: Afficher
      :action:      l’état d'une option
      :mode: command
      :code: ':set <option>?'
      :memo: "((?)) interroger"

    -
      :main_action: Activer
      :action:      une option off/on
      :mode: command
      :code: ':set <option>'

    -
      :main_action: Désactiver
      :action:      une option
      :code: ':set no<option>'

    -
      :main_action: Régler
      :action:      une option sur sa valeur par défaut
      :mode: command
      :code: ':set <option>&'

    -
      :main_action: Régler
      :action:      toutes les options sur leur valeur par défaut
      :mode: command
      :code: ':set all&'

    -
      :main_action: Inverser
      :action:      la valeur d’une option
      :mode: command
      :code:
        - ':set <option>!'
        - ':set inv<option>'
      :exemples:
        - '`:set wrap!` => si l’« enroulage » avait été désactivé avec `:set nowrap` avant, il est remis avec cette commande.'

    -
      :main_action: Augmenter
      :action:      la valeur d’une option numérique
      :mode: command
      :code: ':set <option>+=<valeur numérique>'

    -
      :main_action: Diminuer
      :action:      la valeur d’une option numérique
      :mode: command
      :code: ':set <option>-=<valeur numérique>'

    -
      :main_action: Multiplier
      :action:      la valeur d’une option numérique
      :mode: command
      :code: ':set <option>^=<valeur numérique>'

    -
      :main_action: Ajouter
      :action:      une valeur à une option liste
      :mode: command
      :code: ':set <option>+=<valeur string>'
      :exemples:
        - '`:set cinwords+=test` => cinwords contient `["test"]`, `:set cinwords+=end` => cinwords = `["test","end"]`'

    -
      :main_action: Retirer
      :action:      une valeur à une option liste
      :mode: command
      :code: ':set <option>-=<valeur>'
      :exemples:
        - 'si `cinwords` a la valeur `["test", "end"]` alors le code `:set cinwords-=test` la mettra à `["end"]`'

    -
      :main_action: Activer[/désactiver]
      :action:      la confirmation au lieu de l’erreur
      :mode: command
      :code: ':set [no]confirm'
      :note: 'Par exemple, en tant normal, lorsque l’on veut quitter Vim mais que le fichier courant a été modifié sans être enregistré, Vim provoque une erreur. Avec l’option `confirm` activée, Vim demande s’il faut sauver le fichier avant.'
      :important: true

    -
      :main_action: Augmenter
      :action:      le nombre de lignes pour l’affichage d’une commande
      :mode: command
      :code: ':set cmdheight=<nombre lignes>'

    -
      :main_action: Afficher[/masquer]
      :action:      le mode en bas à gauche de l’écran
      :mode: command
      :code: ':set [no]showmode'

    -
      :main_action: Afficher[/masquer]
      :action:      la commande en version réduite en bas à droite de l’écran
      :mode: command
      :code: ':set [no]showcmd'

    -
      :main_action: Activer[/désactiver]
      :action:      l’alerte visuelle (flash de l’écran)
      :mode: command
      :code: ':set [no]visualbell'

    -
      :main_action: Activer[/désactiver]
      :action:      l’alerte sonore
      :mode: command
      :code: ':set [no]errorbell'

    -
      :main_action: Définir
      :action:      l’ampleur du scroll avec CTRL KeyU
      :code: ":set scroll=<nombre de lignes>"

    -
      :main_action: Définir
      :action:      la hauteur minimum d’une fenêtre au split
      :mode: command
      :code: ':set winheight=<nombre lignes>'

    -
      :main_action: Définir
      :action:      la largeur minimum d’une fenêtre au split vertical
      :mode: command
      :code: ':set winwidth=<nombre colonnes>'

    -
      :main_action: Définir
      :action: 'que le split [ne] doit [pas] faire deux parties égales'
      :mode: command
      :code: ':set [no]equalalways'

# ---------------------------------------------------------------------
#
#   @@@ NERDTree
#
# ---------------------------------------------------------------------

  NERDTree:

    -
      :main_action: Ouvrir
      :action:      le NERDTree
      :code: CTRL KeyN
      :memo: "((n))erd"

    -
      :main_action: Régler
      :action:      le dossier courant en dossier racine
      :mode: normal
      :code: MAJ KeyC
      :memo: "((c))urrent"

# ---------------------------------------------------------------------
#
#     @@@ MODE COMMAND-LINE (EX)
#
# ---------------------------------------------------------------------

  MODE LIGNE DE COMMANDE (EX):

    -
      :main_action: Basculer
      :action:      en mode ligne de commande (ex, grand-père de vim, père de vi)
      :code: "gQ (KeyG, MAJ KeyQ)"

    -
      :main_action: Basculer
      :action:      en mode normal depuis le mode ligne de commande
      :mode: command
      :code: ":visual"

    -
      :main_action: Basculer
      :action: "en mode « shell » (ligne de commande du Terminal)"
      :code: ":shell"
      :note: "Taper «exit» pour revenir dans Vim."

# ---------------------------------------------------------------------
#
#     @@@ FENÊTRES (NON ESSENTIELS)
#
# ---------------------------------------------------------------------

  FENÊTRES (non essentiels):

    -
      :main_action: Activer
      :action:      la fenêtre inférieure
      :mode: normal
      :code: CTRL KeyW KeyJ
      :memo: ((w))indow, ((j)) = descendre

    -
      :main_action: Activer
      :action:      la fenêtre du bas
      :mode: normal
      :code: CTRL KeyW KeyB
      :memo: "((w))indow, ((b))ottom / ((b))as"

    -
      :main_action: Activer
      :action:      la fenêtre supérieure
      :mode: normal
      :code: CTRL KeyW KeyK
      :memo: "((w)) = window, ((k)) = monter"

    -
      :main_action: Activer
      :action:      la fenêtre du haut
      :mode: normal
      :code: CTRL KeyW KeyT
      :memo: "((w))indow, ((t))op"

    -
      :main_action: Activer
      :action:      la fenêtre précédente
      :mode: normal
      :code: "CTRL KeyW, KeyP"
      :note: "Attention, CTRL KeyW, KeyN ne passe pas à la suivante (next) mais crée un nouveau split."

    -
      :main_action: Intervertir
      :action: deux fenêtres
      :mode: normal
      code: 'CTRL KeyW KeyR'

    -
      :main_action: Intervertir
      :action: "la fenêtre courante avec la suite (celle en dessous)"
      :mode: normal
      :code: CTRL KeyW KeyX
      :note: 'S’il n’y a pas de fenêtre en dessous, intervertit avec la précédente.'

    -
      :main_action: "Égaliser"
      :action: "les dimensions des fenêtres"
      :code: "CTRL KeyW ="
      :memo: "((w))indow, ((=)) égal"

    -
      :main_action: Modifier
      :action: "la taille des fenêtres"
      :code: "CTRL KeyW +/-"
      :memo: "((w))indow"

    -
      :main_action: "Interchanger"
      :action: "la disposition des fenêtres"
      :code: CTRL KeyW KeyR/MAJ KeyR
      :memo: "((w))indow, ((r))epositionne"

# ---------------------------------------------------------------------
#
#   @@@ CTRLP
#
# ---------------------------------------------------------------------

  CTRLP:

    -
      :main_action: "Ouvrir CtrlP"
      :action: "en mode de recherche \"files\""
      :mode: normal
      :code:
        - ":CtrlP"
        - "CTRL KeyP"

    -
      :main_action: "Ouvrir CtrlP"
      :action: "MRU"
      :mode: normal
      :code: ":CtrlPMRU"

    -
      :main_aciton: null
      :action: MRU signifie
      :code: "((M))ost ((R))ecently ((U))sed"
      :memo: "= les fichiers récemment utilisés"

    -
      :main_action: Définir
      :action: "chercher par path/chercher par filename (basculer)"
      :code: CTRL KeyP CTRL KeyD

    -
      :main_action: Définir
      :action: "le mode de recherche par défaut à REGEXP"
      :code: "[.vimrc] let g:ctrlp_regexp = 1"

    -
      :main_action: Définir
      :action: "mode de recherche par regexp / mode de recherche normal (bascule)"
      :code: CTRL KeyP CTRL KeyR
      :memo: "((r))eg expression"

    -
      :main_action: Définir
      :action: "le mode suivant (((f))oward) ou précédent (((b))ackward) (?)"
      :code:
        - CTRL KeyP CTRL Keyf
        - CTRL KeyP CTRL Keyb

    -
      :main_action: Définir
      :action: "le dossier courant à la sélection et passer en mode find file"
      :code: "CTRL KeyO puis KeyD"

    -
      :main_action: Définir
      :action:      le dossier courant
      :code: "@cd path/to/folder/"
      :exemples:
        - "On peut aussi ouvrir vim dans le dossier (à vérifier)"

    -
      :main_action: Définir
      :action:      dossier du fichier courant comme dossier courant
      :code: "@cd %:h"

    -
      :main_action: Vider
      :action:      le cache
      :code: F5

    -
      :main_action: Définir
      :action:      les fichiers/dossiers exclus des résultats
      :code: "Utiliser le `wildignore` de vim\nOu let g:ctrlp_custom_ignore = ''"
      :memo: "`set wildignore+=...,...,...`"

    -
      :main_action: Chercher
      :action:      des résultats dans l’historique
      :code: CTRL KeyN et CTRL KeyP

    -
      :main_action: Marquer/démarquer
      :action:      des fichiers à ouvrir
      :code: CTRL KeyZ
      :memo: Peut le marquer aussi pour le créer (et ses parents)

    -
      :main_action: Ouvrir
      :action:      'plusieurs fichiers marqués par CTRL-z'
      :code: CTRL KeyO
      :memo: "Voir les valeurs l'option g:ctrlp_open_multiple_files"

    -
      :main_action: Ouvrir
      :action:      le fichier dans une nouvelle tab
      :code: CTRL KeyT
      :memo: '((t))ab'

    -
      :main_action: Ouvrir
      :action:      le fichier dans un split horizontal
      :code:
        - CTRL KeyX
        - CTRL KeyS
        - CTRL ENTER
      :memo: "((s))plit"

    -
      :main_action: Déplacer la sélection
      :action:      vers le bas
      :mode: insert
      :code: CTRL KeyJ
      :memo: "((j)) comme le déplacement dans Vim"

    -
      :main_action: Déplacer la sélection
      :action:      vers le haut
      :mode: insert
      :code: CTRL KeyK
      :memo: '((k)) comme le déplacement dans Vim'
      :note: 'Je ne suis pas sûr du tout que ça fasse ça…'

    -
      :main_action: Déplacer le curseur
      :action:      au début du prompt
      :code: CTRL KeyA
      :memo: ((a)) = première lettre alphabet.

    -
      :main_action: "Déplacer le curseur"
      :action: "vers la gauche"
      :code: CTRL KeyH
      :memo: ((h)) comme le déplacement dans Vim

    -
      :main_action: "Déplacer le curseur"
      :action: "vers la droite"
      :code: CTRL KeyL
      :memo: "((l)) comme le déplacement dans Vim"

    -
      :main_action: "Déplacer le curseur"
      :action: "à la fin du prompt"
      :code: CTRL KeyE
      :memo: "((e))nd"

    -
      :main_action: Supprimer
      :action: 'le mot précédent (dans le prompt)'
      :mode: normal
      :code: CTRL KeyW
      :memo: "((w))ord"

    -
      :main_action: Supprimer
      :action:      tout le texte de la console
      :code: CTRL KeyU

    -
      :main_action: Supprimer
      :action:      la sélection sans la mettre dans un registre quelconque
      :mode: normal
      :code: '"_KeyD<motion>'
      :exemples:
        - '`"_KeyDKeyD` => Supprime la ligne, sans la conserver dans le registre "1'
      :note: 'Ce registre spécial s’appelle le « black hole », le trou noir. Il permet de ne pas mémoriser la suppression dans les registres de 1 à 9.'

    -
      :main_action: Sélectionner
      :action:      le prochain string dans l’historique
      :code: CTRL KeyN
      :memo: "((n))ext"

    -
      :main_action: Sélectionner
      :action:      le précédent string dans l’historique
      :code: CTRL KeyP
      :memo: "((p))revious"

    -
      :main_action: Créer
      :action:      un fichier et tous ses dossiers parents
      :code: CTRL KeyY

    -
      :main_action: Quitter CtrlP
      :code:
        - CTRL KeyC
        - ESC

# ---------------------------------------------------------------------
#
#   @@@ SIGNES
#
# ---------------------------------------------------------------------

  SIGNES:

    -
      :main_action: Définir
      :action: un sign
      :mode: normal
      :code: ":sign define <nom> text=<texte> texthl=<groupe>"
      :note: "Il y a d'autres paramètres possibles, voir l'aide"

    -
      :main_action: Placer
      :action: un signe
      :mode: normal
      :code: ":sign place <ID signe> line=<ligne> name=<nom du signe> file=<fichier>|buffer=<ID>"
      :exemples:
        - "`:sign place 2 line=3 name=MonSigne file=courant.txt`"

    -
      :main_action: Supprimer
      :action: un signe
      :mode: normal
      :code: ":sign unplace <ID sign>[ file=<fichier>|buffer=<id buffer>]"

    -
      :main_action: Supprimer
      :action: tous les signes
      :mode: normal
      :code: ":sign unplace *"

    -
      :main_action: Se rendre
      :action: à un signe particulier
      :mode: normal
      :code: ":sign jump <ID signe>[ file=<fichier>|buffer=<id buffer>]"

    -
      :main_action: Afficher
      :action:      la liste des signes
      :mode: normal
      :code: ":sign list[ file=<fichier>|buffer=<id buf>]"

    -
      :main_action: Afficher
      :action: les marques d'un signe en particulier
      :mode: normal
      :code: ":sign line <nom du fichier>"
# ---------------------------------------------------------------------
#
#   @@@ CTAGS
#
# ---------------------------------------------------------------------

  CTAGS:

    -
      :main_action: Générer
      :action: "le repérage des tags/méthodes"
      :mode: "$>"
      :code: "ctags -R"

    -
      :main_action: Aller
      :action:      à la définition d'une méthode
      :code: "CTRL ] (CTRL KeyDollar sur mac ?)"

    -
      :main_action: Aller
      :action:      à la définition d’une méthode par son nom
      :code: ":tag <nom de la méthode>"

    -
      :main_action: Revenir
      :action: "à la position de départ"
      :code: CTRL KeyO


# ---------------------------------------------------------------------
#
#  @@@ FONCTIONS
#
# ---------------------------------------------------------------------

  FONCTIONS:

    -
      :main_action: Afficher
      :action:      la liste des fonctions
      :mode: command
      :code: ':function'

    -
      :main_action: Afficher
      :action:      le code d’une fonction en particulier
      :mode: command
      :code: ':function <FonctionName>'

    -
      :main_action: Résumé
      :action: complet
      :mode: command
      :code: |
        ```
        " Déclaration d'une variable globale hors d'une fonction
        var variableGlobale = 12

        " Définition de la fonction (doit commencer par une capitale)
        :function MaFonction(var1, var2, var3)

          " Référence aux arguments dans la fonction
          if a:var1 > a:var3

          else

          endif

          " Définition d'une variable locale varFonction et
          " Utilisation de la variable globale dans la fonction
          let varFonction = g:variableGlobale

          " Pour retourner une valeur
          :return varFonction
        :endfunction " fin de la fonction

        " Fonction « à rang » (range)
        " Fonction s'interrompant à la première erreur (abort)
        " Fonction à nombre d'arguments variables (19 en tout)
        :function FonctionARangDeLignes(start,...) range abort

          " Nombre d'arguments
          let nombreArguments = a:0

          " Référence aux trois premiers arguments
          let primo  = a:start
          let deuxio = a:1
          let tercio = a:2


          " `a:firstline` est une référence au NUMÉRO de la première ligne du rang
          " `a:lastline` est une référence au NUMÉRO de la dernière ligne du rang
          let premiereLigne = a:firstline
          let derniereLigne = a:lastline

        :endfunction
        ```

    -
      :main_action: Invoquer
      :action:      une fonction sur chaque ligne du texte courant
      :mode: command
      :code: ':<rang> call <NomFonction>([<arguments>])'

    -
      :main_action: Définir
      :action:      une fonction
      :mode: command
      :code: '```:function <Name>(<vars,...>)\n  <code>\n:endfunction```'
      :note: 'Le nom doit commencer par une capitale.'

    -
      :main_action: Référence
      :action:      à un argument de la fonction
      :mode: command
      :code: 'a:<nom de l’argument>'
      :exemples:
        - '```:function Max(nombre1, nombre2)\n: if a:nombre1 > a:nombre2\n    ...\n...\n:endfunction```'

    -
      :main_action: Définir
      :action:      un type de variable
      :mode: command
      :code:
        - '`var variable = ...` définit une variable globable à l’extérieur d’une fonction, MAIS on doit y faire référence par `g:variable` à l’intérieur de la fonction.'
        - '`let variable = ...`, à l’intérieur d’une fonction, définit une variable locale à la fonction'
        - '`g:variable = ...` définit une variable globale.'

    -
      :main_action: Retourner
      :action:      une valeur calculée par la fonction
      :mode: command
      :code: ':return <valeur>'

# ---------------------------------------------------------------------
#
#  @@@ DIVERS
#
# ---------------------------------------------------------------------

  DIVERS:

    -
      :main_action: Afficher
      :action:      'la valeur entre `<` et `>` d’une touche'
      :mode: insert
      :code: 'CTRL KeyK <touche>'
      :exemples:
        - '`CTRL KeyK F2` => va afficher `<F2>`'

    -
      :main_action: Afficher
      :action:      l’historique de toutes les actions
      :mode: command
      :code:
        - ':history all'
        - ':his a'
      :tags: history

    -
      :main_action: Afficher
      :action:      l’historique des commandes
      :mode: command
      :code: ':his[tory]'
      :tags: history

    -
      :main_action: Afficher
      :action:      l’historique d’un certain type d’élément [d’une ligne à une autre]
      :mode: command
      :code: ':his[tory] <type> [<from>, <to>]'
      :values:
        '<type>':
          - '`a` : tous les types'
          - '`s` : type recherche (avec le préfixe `/`)'
          - '`c` : type commande (avec le préfixe `:`)'
          - '`i` : type insert (avec le préfixe `@`, donnée tapées avec un `:insert`)'
      :exemples:
        - '`:history c 1, 10` => affiche l’historique des commandes de la première à la dixième'
        - '`his s 4, 5` => affiche l’historique des recherches de la 4e à la 5e'
        - '`his a -5,` => affiche les cinq dernières lignes de l’historique complet'
      :tags: history

    -
      :main_action: Définir
      :action:      le nombre de lignes de l’historique (:history) à conserver
      :mode: normal
      :code: ":set hi[story]=<nombre lignes>"
      :exemples:
        - '`:set hi=100` => 100 lignes d’historique seront conservées'
      :tags: history

    -
      :main_action: Afficher
      :action:      les messages notice et erreurs
      :mode: command
      :code: ':mess[ages]'

    -
      :main_action: Rediriger
      :action:      les messages vers un fichier plutôt qu’en console
      :mode: command
      :code: ':redir > <path/to/file.ext>'
      :note: 'Noter que ça ne fonctionne qu’une fois. Sinon il faut utiliser l’ajout avec `>>`'
      :exemples:
        - '`:redir > ~/mon.log`'

    -
      :main_action: Rediriger
      :action:      les messages en les ajoutant au fichier
      :mode: command
      :code: ':redir >> <path/to/file.ext>'
      :exemples:
        - '`:redir >> ~/mon.log`'

    -
      :main_action: Stopper
      :action:      la redirection
      :mode: command
      ;code: ':redir END'

    -
      :main_action: Exécuter
      :action:      une commande en mode commande
      :mode: command
      :code: ':norm[al] <commande complète>'
      :exemples:
        - '`:norm cwDone` => efface le mot sous le cuseur (`cw`) et tape `Done` à la place'
        - '`:normal! cwSA` => efface le mot sous le curseur et tape « SA » sans exécuter de mapping (par exemple, ici, « SA » serait remplacé par « Société Anonyme »).'
      :note: 'En « programmation », il est important de « finir » les commandes, par exemple avec `<ESC>`'

    -
      :main_action: Afficher
      :action:      la liste des annulations possibles
      :mode: normal
      :code: ":undolist"
      :tags: undo
    -
      :main_action: Revenir
      :action:      à une annulation précise
      :mode: normal
      :code: ":undo <numéro annulation>"
      :note: "On obtient le numéro d'annulation à l'aide de `:undolist`"
      :tags: undo

    -
      :main_action: Afficher
      :action:      le nom du terminal courant
      :mode: command
      :code: ':set term?'
      :note: 'C’est donc l’option `term` qui contient ce nom (mais je crois qu’elle ne se règle pas)'

    -
      :main_action: Régler
      :action:      le mode verbeux (verbose)
      :mode: command
      :code: ':set verbose=<valeur>'
      :note: "Pour les valeurs, voir l’aide (`:help 'verbose'`)"

    -
      :main_action: Régler
      :action:      le mode silencieux [sans message d’erreur]
      :mode: command
      :code: ':set silent[!]'
      :exemples:
        - '`:set silent` => n’affiche que les messages d’erreur'
        - '`:set silent!` => n’affiche rien, pas même les messages d’erreur (i.e. mode sans erreur)'
---
